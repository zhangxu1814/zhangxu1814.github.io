<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>Hyperledger Burrow中的evm及相关组件源码分析 - SSSSSSS</title><meta name=Description content="This blog is used to record my study"><meta property="og:title" content="Hyperledger Burrow中的evm及相关组件源码分析"><meta property="og:description" content="
Hyperledger Burrow是Hyperledger下的一个子项目，它实现了符合以太坊规范的EVM，这篇文章中对evm及相关代码进行了分析"><meta property="og:type" content="article"><meta property="og:url" content="https://zhangxu1814.github.io/burrow-evm/"><meta property="og:image" content="https://zhangxu1814.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-23T20:53:34+08:00"><meta property="article:modified_time" content="2021-05-23T20:53:34+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zhangxu1814.github.io/logo.png"><meta name=twitter:title content="Hyperledger Burrow中的evm及相关组件源码分析"><meta name=twitter:description content="
Hyperledger Burrow是Hyperledger下的一个子项目，它实现了符合以太坊规范的EVM，这篇文章中对evm及相关代码进行了分析"><meta name=application-name content="zhangxu1814"><meta name=apple-mobile-web-app-title content="zhangxu1814"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://zhangxu1814.github.io/burrow-evm/><link rel=prev href=https://zhangxu1814.github.io/slices_in_go/><link rel=next href=https://zhangxu1814.github.io/interface_in_go/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Hyperledger Burrow中的evm及相关组件源码分析","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/zhangxu1814.github.io\/burrow-evm\/"},"genre":"posts","keywords":"evm","wordcount":12627,"url":"https:\/\/zhangxu1814.github.io\/burrow-evm\/","datePublished":"2021-05-23T20:53:34+08:00","dateModified":"2021-05-23T20:53:34+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"zhangxu1814"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><a href=https://github.com/zhangxu1814 class=github-corner target=_blank title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="3.5rem" height="3.5rem" viewBox="0 0 250 250" style="fill:#70b7fd;color:#fff;position:absolute;top:0;border:0;left:0;transform:scale(-1,1)" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div class=header-title><a href=/ title=SSSSSSS>zhangxu1814</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/>关于 </a><a class=menu-item href=https://github.com/zhangxu1814 title=Github rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i> </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=SSSSSSS>zhangxu1814</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/about/ title>关于</a><a class=menu-item href=https://github.com/zhangxu1814 title=Github rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i></a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">Hyperledger Burrow中的evm及相关组件源码分析</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://zhangxu1814.github.io title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>zhangxu1814</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/evm/><i class="far fa-folder fa-fw"></i>evm</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-05-23>2021-05-23</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 12627 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 26 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#acm>acm</a><ul><li><a href=#acmstate>acmstate</a><ul><li><a href=#statego>state.go</a></li><li><a href=#state_cachego>state_cache.go</a></li><li><a href=#acmaccountgo>acm/account.go</a></li></ul></li></ul></li><li><a href=#execution>execution</a><ul><li><a href=#engine>engine</a><ul><li><a href=#accountgo>account.go</a></li><li><a href=#accountsgo>accounts.go</a></li><li><a href=#blockchaingo>blockchain.go</a></li><li><a href=#call_framego>call_frame.go</a></li><li><a href=#callgo>call.go</a></li><li><a href=#callablego>callable.go</a></li><li><a href=#dispatchergo>dispatcher.go</a></li><li><a href=#gasgo>gas.go</a></li><li><a href=#enginenativesgo>engine/natives.go</a></li><li><a href=#optionsgo>options.go</a></li><li><a href=#enginestatego>engine/state.go</a></li></ul></li><li><a href=#evm>evm</a><ul><li><a href=#abi>abi</a><ul><li><a href=#abigo>abi.go</a></li><li><a href=#event_specgo>event_spec.go</a></li><li><a href=#function_specgo>function_spec.go</a></li><li><a href=#packinggo>packing.go</a></li><li><a href=#primitivesgo>primitives.go</a></li></ul></li><li><a href=#codego>code.go</a></li><li><a href=#evmcontractgo>evm/contract.go</a></li><li><a href=#evmgo>evm.go</a></li><li><a href=#stackgo>stack.go</a></li></ul></li><li><a href=#native>native</a><ul><li><a href=#contractgo>contract.go</a></li><li><a href=#functiongo>function.go</a></li><li><a href=#nativego>native.go</a></li><li><a href=#nativenativesgo>native/natives.go</a></li><li><a href=#permissionsgo>permissions.go</a></li><li><a href=#precompilesgo>precompiles.go</a></li><li><a href=#nativestatego>native/state.go</a></li></ul></li></ul></li><li><a href=#参考链接>参考链接</a></li></ul></nav></div></div><div class=content id=content><p>Hyperledger Burrow是Hyperledger下的一个子项目，它实现了符合以太坊规范的EVM，这篇文章中对evm及相关代码进行了分析</p><h2 id=acm>acm</h2><p>acm中包含了账户以及账户状态相关的代码</p><p>该文件夹的名称大概来源于“<strong>ac</strong>count <strong>m</strong>anagement”</p><h3 id=acmstate>acmstate</h3><h4 id=statego>state.go</h4><p><code>state.go</code> 中定义了两个hash值类型以及对应的编码/解码操作，还定义了对账户、存储、元数据的读/写/遍历操作接口</p><p>Metadatahash，表示元数据的hash，用于元数据寻址，为256位的字节数组；Codehash，表示账户中存储的代码的hash，用于CODEHASH指令，为256为字节数组。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// MetadataHash is the keccak hash for the metadata. This is to make the metadata content-addressed
</span><span class=c1></span><span class=kd>type</span> <span class=nx>MetadataHash</span> <span class=p>[</span><span class=mi>32</span><span class=p>]</span><span class=kt>byte</span>

<span class=c1>// CodeHash is the keccak hash for the code for an account. This is used for the EVM CODEHASH opcode, and to find the
</span><span class=c1>// correct Metadata for a contract
</span><span class=c1></span><span class=kd>type</span> <span class=nx>CodeHash</span> <span class=p>[</span><span class=mi>32</span><span class=p>]</span><span class=kt>byte</span>
</code></pre></td></tr></table></div></div><p>最常使用的接口为ReaderWriter接口，也就是<a href=#evmgo rel>evm</a>在执行时所需的第一个参数，它包括了对于账户和存储的读写操作</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// Read and write account and storage state
</span><span class=c1></span><span class=kd>type</span> <span class=nx>ReaderWriter</span> <span class=kd>interface</span> <span class=p>{</span>
	<span class=nx>Reader</span>
	<span class=nx>Writer</span>
<span class=p>}</span>

<span class=c1>// Read-only account and storage state
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Reader</span> <span class=kd>interface</span> <span class=p>{</span>
	<span class=nx>AccountGetter</span>
	<span class=nx>StorageGetter</span>
<span class=p>}</span>

<span class=kd>type</span> <span class=nx>Writer</span> <span class=kd>interface</span> <span class=p>{</span>
	<span class=nx>AccountUpdater</span>
	<span class=nx>StorageSetter</span>
<span class=p>}</span>

<span class=kd>type</span> <span class=nx>AccountGetter</span> <span class=kd>interface</span> <span class=p>{</span>
	<span class=c1>// Get an account by its address return nil if it does not exist (which should not be an error)
</span><span class=c1></span>	<span class=nf>GetAccount</span><span class=p>(</span><span class=nx>address</span> <span class=nx>crypto</span><span class=p>.</span><span class=nx>Address</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>acm</span><span class=p>.</span><span class=nx>Account</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>type</span> <span class=nx>StorageGetter</span> <span class=kd>interface</span> <span class=p>{</span>
	<span class=c1>// Retrieve a 32-byte value stored at key for the account at address, return Zero256 if key does not exist but
</span><span class=c1></span>	<span class=c1>// error if address does not
</span><span class=c1></span>	<span class=nf>GetStorage</span><span class=p>(</span><span class=nx>address</span> <span class=nx>crypto</span><span class=p>.</span><span class=nx>Address</span><span class=p>,</span> <span class=nx>key</span> <span class=nx>binary</span><span class=p>.</span><span class=nx>Word256</span><span class=p>)</span> <span class=p>(</span><span class=nx>value</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>type</span> <span class=nx>AccountUpdater</span> <span class=kd>interface</span> <span class=p>{</span>
	<span class=c1>// Updates the fields of updatedAccount by address, creating the account
</span><span class=c1></span>	<span class=c1>// if it does not exist
</span><span class=c1></span>	<span class=nf>UpdateAccount</span><span class=p>(</span><span class=nx>updatedAccount</span> <span class=o>*</span><span class=nx>acm</span><span class=p>.</span><span class=nx>Account</span><span class=p>)</span> <span class=kt>error</span>
	<span class=c1>// Remove the account at address
</span><span class=c1></span>	<span class=nf>RemoveAccount</span><span class=p>(</span><span class=nx>address</span> <span class=nx>crypto</span><span class=p>.</span><span class=nx>Address</span><span class=p>)</span> <span class=kt>error</span>
<span class=p>}</span>

<span class=kd>type</span> <span class=nx>StorageSetter</span> <span class=kd>interface</span> <span class=p>{</span>
	<span class=c1>// Store a 32-byte value at key for the account at address, setting to Zero256 removes the key
</span><span class=c1></span>	<span class=nf>SetStorage</span><span class=p>(</span><span class=nx>address</span> <span class=nx>crypto</span><span class=p>.</span><span class=nx>Address</span><span class=p>,</span> <span class=nx>key</span> <span class=nx>binary</span><span class=p>.</span><span class=nx>Word256</span><span class=p>,</span> <span class=nx>value</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=kt>error</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p><code>state.go</code> 中还定义了一个函数用于获取全局账户权限</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// Get global permissions from the account at GlobalPermissionsAddress
</span><span class=c1></span><span class=kd>func</span> <span class=nf>GlobalAccountPermissions</span><span class=p>(</span><span class=nx>getter</span> <span class=nx>AccountGetter</span><span class=p>)</span> <span class=p>(</span><span class=nx>permission</span><span class=p>.</span><span class=nx>AccountPermissions</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>acc</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>getter</span><span class=p>.</span><span class=nf>GetAccount</span><span class=p>(</span><span class=nx>acm</span><span class=p>.</span><span class=nx>GlobalPermissionsAddress</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>permission</span><span class=p>.</span><span class=nx>AccountPermissions</span><span class=p>{},</span> <span class=nx>err</span>
	<span class=p>}</span>
	<span class=k>if</span> <span class=nx>acc</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>permission</span><span class=p>.</span><span class=nx>AccountPermissions</span><span class=p>{},</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;global permissions account is not defined but must be&#34;</span><span class=p>)</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=nx>acc</span><span class=p>.</span><span class=nx>Permissions</span><span class=p>,</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>全局账户权限地址定义在<a href=#acmaccountgo rel>account.go</a>中，为零值地址，该地址的权限字段包含了账户允许设置的全部权限</p><h4 id=state_cachego>state_cache.go</h4><p><code>state_cache.go</code> 定义了缓存的类型，对缓存内容的操作以及将缓存内容写回的方法。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>Cache</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span>                               <span class=c1>//读写锁
</span><span class=c1></span>	<span class=nx>name</span>     <span class=kt>string</span>                            <span class=c1>//缓存名称
</span><span class=c1></span>	<span class=nx>backend</span>  <span class=nx>Reader</span>                            <span class=c1>//读操作接口，包括读取账户和读取存储
</span><span class=c1></span>	<span class=nx>accounts</span> <span class=kd>map</span><span class=p>[</span><span class=nx>crypto</span><span class=p>.</span><span class=nx>Address</span><span class=p>]</span><span class=o>*</span><span class=nx>accountInfo</span>   <span class=c1>//具体缓存的内容
</span><span class=c1></span>	<span class=nx>readonly</span> <span class=kt>bool</span>                              <span class=c1>//只读标志位
</span><span class=c1></span><span class=p>}</span>

<span class=kd>type</span> <span class=nx>accountInfo</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span>                               <span class=c1>//读写锁
</span><span class=c1></span>	<span class=nx>account</span> <span class=o>*</span><span class=nx>acm</span><span class=p>.</span><span class=nx>Account</span>                       <span class=c1>//账户
</span><span class=c1></span>	<span class=nx>storage</span> <span class=kd>map</span><span class=p>[</span><span class=nx>binary</span><span class=p>.</span><span class=nx>Word256</span><span class=p>][]</span><span class=kt>byte</span>          <span class=c1>//账户的存储
</span><span class=c1></span>	<span class=nx>removed</span> <span class=kt>bool</span>                               <span class=c1>//账户是否已经移除
</span><span class=c1></span>	<span class=nx>updated</span> <span class=kt>bool</span>                               <span class=c1>//账户是否需要更新
</span><span class=c1></span><span class=p>}</span>

<span class=kd>type</span> <span class=nx>CacheOption</span> <span class=kd>func</span><span class=p>(</span><span class=o>*</span><span class=nx>Cache</span><span class=p>)</span> <span class=o>*</span><span class=nx>Cache</span>           <span class=c1>//使用示例如ReadOnly
</span><span class=c1></span>
<span class=kd>var</span> <span class=nx>ReadOnly</span> <span class=nx>CacheOption</span> <span class=p>=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>cache</span> <span class=o>*</span><span class=nx>Cache</span><span class=p>)</span> <span class=o>*</span><span class=nx>Cache</span> <span class=p>{</span>
	<span class=nx>cache</span><span class=p>.</span><span class=nx>readonly</span> <span class=p>=</span> <span class=kc>true</span>
	<span class=k>return</span> <span class=nx>cache</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Cache实现了ReaderWriter接口，但是所有方法均是对缓存中的accountInfo进行操作，每种方法都会先检查账户/存储是否在缓存中，如果没有，则将其加入缓存</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// Syncs changes to the backend in deterministic order. Sends storage updates before updating
</span><span class=c1>// the account they belong so that storage values can be taken account of in the update.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>cache</span> <span class=o>*</span><span class=nx>Cache</span><span class=p>)</span> <span class=nf>Sync</span><span class=p>(</span><span class=nx>st</span> <span class=nx>Writer</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
	<span class=k>if</span> <span class=nx>cache</span><span class=p>.</span><span class=nx>readonly</span> <span class=p>{</span>
		<span class=c1>// Sync is (should be) a no-op for read-only - any modifications should have been caught in respective methods
</span><span class=c1></span>		<span class=k>return</span> <span class=kc>nil</span>
	<span class=p>}</span>
	<span class=nx>cache</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
	<span class=k>defer</span> <span class=nx>cache</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
	<span class=kd>var</span> <span class=nx>addresses</span> <span class=nx>crypto</span><span class=p>.</span><span class=nx>Addresses</span>
	<span class=k>for</span> <span class=nx>address</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>cache</span><span class=p>.</span><span class=nx>accounts</span> <span class=p>{</span>
		<span class=nx>addresses</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>addresses</span><span class=p>,</span> <span class=nx>address</span><span class=p>)</span>
	<span class=p>}</span>

	<span class=nx>sort</span><span class=p>.</span><span class=nf>Sort</span><span class=p>(</span><span class=nx>addresses</span><span class=p>)</span>
	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>address</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>addresses</span> <span class=p>{</span>
		<span class=nx>accInfo</span> <span class=o>:=</span> <span class=nx>cache</span><span class=p>.</span><span class=nx>accounts</span><span class=p>[</span><span class=nx>address</span><span class=p>]</span>
		<span class=nx>accInfo</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span>
		<span class=k>if</span> <span class=nx>accInfo</span><span class=p>.</span><span class=nx>removed</span> <span class=p>{</span>
			<span class=nx>err</span> <span class=o>:=</span> <span class=nx>st</span><span class=p>.</span><span class=nf>RemoveAccount</span><span class=p>(</span><span class=nx>address</span><span class=p>)</span>
			<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
				<span class=k>return</span> <span class=nx>err</span>
			<span class=p>}</span>
		<span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>accInfo</span><span class=p>.</span><span class=nx>updated</span> <span class=p>{</span>
			<span class=c1>// First update account in case it needs to be created
</span><span class=c1></span>			<span class=nx>err</span> <span class=o>:=</span> <span class=nx>st</span><span class=p>.</span><span class=nf>UpdateAccount</span><span class=p>(</span><span class=nx>accInfo</span><span class=p>.</span><span class=nx>account</span><span class=p>)</span>
			<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
				<span class=k>return</span> <span class=nx>err</span>
			<span class=p>}</span>
			<span class=c1>// Sort keys
</span><span class=c1></span>			<span class=kd>var</span> <span class=nx>keys</span> <span class=nx>binary</span><span class=p>.</span><span class=nx>Words256</span>
			<span class=k>for</span> <span class=nx>key</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>accInfo</span><span class=p>.</span><span class=nx>storage</span> <span class=p>{</span>
				<span class=nx>keys</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>keys</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span>
			<span class=p>}</span>
			<span class=nx>sort</span><span class=p>.</span><span class=nf>Sort</span><span class=p>(</span><span class=nx>keys</span><span class=p>)</span>
			<span class=c1>// Update account&#39;s storage
</span><span class=c1></span>			<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>key</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>keys</span> <span class=p>{</span>
				<span class=nx>value</span> <span class=o>:=</span> <span class=nx>accInfo</span><span class=p>.</span><span class=nx>storage</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span>
				<span class=nx>err</span> <span class=o>:=</span> <span class=nx>st</span><span class=p>.</span><span class=nf>SetStorage</span><span class=p>(</span><span class=nx>address</span><span class=p>,</span> <span class=nx>key</span><span class=p>,</span> <span class=nx>value</span><span class=p>)</span>
				<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
					<span class=k>return</span> <span class=nx>err</span>
				<span class=p>}</span>
			<span class=p>}</span>

		<span class=p>}</span>
		<span class=nx>accInfo</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>
	<span class=p>}</span>

	<span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Cache包含一个Sync方法，需要传入一个实现了Writer接口的类型作为参数，根据removed和updated标志位对账户和存储进行修改</p><h4 id=acmaccountgo>acm/account.go</h4><p><code>account.go</code> 中定义了全局账户权限地址为零值地址，根据公钥/种子密钥新建账户的方法，以及修改账户余额、获取账户代码等账户相关的方法</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=nx>GlobalPermissionsAddress</span> <span class=p>=</span> <span class=nx>crypto</span><span class=p>.</span><span class=nf>Address</span><span class=p>(</span><span class=nx>binary</span><span class=p>.</span><span class=nx>Zero160</span><span class=p>)</span>

<span class=kd>func</span> <span class=nf>NewAccount</span><span class=p>(</span><span class=nx>pubKey</span> <span class=o>*</span><span class=nx>crypto</span><span class=p>.</span><span class=nx>PublicKey</span><span class=p>)</span> <span class=o>*</span><span class=nx>Account</span> <span class=p>{</span>
	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>Account</span><span class=p>{</span>
		<span class=nx>Address</span><span class=p>:</span>   <span class=nx>pubKey</span><span class=p>.</span><span class=nf>GetAddress</span><span class=p>(),</span>
		<span class=nx>PublicKey</span><span class=p>:</span> <span class=nx>pubKey</span><span class=p>,</span>
	<span class=p>}</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>NewAccountFromSecret</span><span class=p>(</span><span class=nx>secret</span> <span class=kt>string</span><span class=p>)</span> <span class=o>*</span><span class=nx>Account</span> <span class=p>{</span>
	<span class=k>return</span> <span class=nf>NewAccount</span><span class=p>(</span><span class=nx>crypto</span><span class=p>.</span><span class=nf>PrivateKeyFromSecret</span><span class=p>(</span><span class=nx>secret</span><span class=p>,</span> <span class=nx>crypto</span><span class=p>.</span><span class=nx>CurveTypeEd25519</span><span class=p>).</span><span class=nf>GetPublicKey</span><span class=p>())</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=execution>execution</h2><p><code>execution</code> 中包含了执行环境相关代码</p><h3 id=engine>engine</h3><h4 id=accountgo>account.go</h4><p><code>account.go</code> 中定义了部署合约代码、部署WASM代码、修改账户状态相关的函数，这些函数被用于<a href=#evmcontractgo rel>contract.go</a>的指令执行中</p><h4 id=accountsgo>accounts.go</h4><p><code>accounts.go</code> 中定义了获取账户、创建账户、权限检查相关的函数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>EnsurePermission</span><span class=p>(</span><span class=nx>callFrame</span> <span class=o>*</span><span class=nx>CallFrame</span><span class=p>,</span> <span class=nx>address</span> <span class=nx>crypto</span><span class=p>.</span><span class=nx>Address</span><span class=p>,</span> <span class=nx>perm</span> <span class=nx>permission</span><span class=p>.</span><span class=nx>PermFlag</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
	<span class=nx>hasPermission</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>HasPermission</span><span class=p>(</span><span class=nx>callFrame</span><span class=p>,</span> <span class=nx>address</span><span class=p>,</span> <span class=nx>perm</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>err</span>
	<span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>!</span><span class=nx>hasPermission</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nx>PermissionDenied</span><span class=p>{</span>
			<span class=nx>Address</span><span class=p>:</span> <span class=nx>address</span><span class=p>,</span>
			<span class=nx>Perm</span><span class=p>:</span>    <span class=nx>perm</span><span class=p>,</span>
		<span class=p>}</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>

<span class=c1>// CONTRACT: it is the duty of the contract writer to call known permissions
</span><span class=c1>// we do not convey if a permission is not set
</span><span class=c1>// (unlike in state/execution, where we guarantee HasPermission is called
</span><span class=c1>// on known permissions and panics else)
</span><span class=c1>// If the perm is not defined in the acc nor set by default in GlobalPermissions,
</span><span class=c1>// this function returns false.
</span><span class=c1></span><span class=kd>func</span> <span class=nf>HasPermission</span><span class=p>(</span><span class=nx>st</span> <span class=nx>acmstate</span><span class=p>.</span><span class=nx>Reader</span><span class=p>,</span> <span class=nx>address</span> <span class=nx>crypto</span><span class=p>.</span><span class=nx>Address</span><span class=p>,</span> <span class=nx>perm</span> <span class=nx>permission</span><span class=p>.</span><span class=nx>PermFlag</span><span class=p>)</span> <span class=p>(</span><span class=kt>bool</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>acc</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>st</span><span class=p>.</span><span class=nf>GetAccount</span><span class=p>(</span><span class=nx>address</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>false</span><span class=p>,</span> <span class=nx>err</span>
	<span class=p>}</span>
	<span class=k>if</span> <span class=nx>acc</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>false</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;account %v does not exist&#34;</span><span class=p>,</span> <span class=nx>address</span><span class=p>)</span>
	<span class=p>}</span>
	<span class=nx>globalPerms</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>acmstate</span><span class=p>.</span><span class=nf>GlobalAccountPermissions</span><span class=p>(</span><span class=nx>st</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>false</span><span class=p>,</span> <span class=nx>err</span>
	<span class=p>}</span>
	<span class=nx>perms</span> <span class=o>:=</span> <span class=nx>acc</span><span class=p>.</span><span class=nx>Permissions</span><span class=p>.</span><span class=nx>Base</span><span class=p>.</span><span class=nf>Compose</span><span class=p>(</span><span class=nx>globalPerms</span><span class=p>.</span><span class=nx>Base</span><span class=p>)</span>
	<span class=nx>value</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>perms</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>perm</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>false</span><span class=p>,</span> <span class=nx>err</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=nx>value</span><span class=p>,</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>这里权限检查是通过调用<a href=#statego rel>state.go</a>中的GlobalAccountPermissions函数来获取作为基准的权限，然后检查该账户设置的基准权限中是否包含目标权限</p><h4 id=blockchaingo>blockchain.go</h4><p><code>blockchain.go</code> 中定义了一个实现了<a href=#callablego rel>Blockchain</a>接口的TestBlockChain类型用于测试</p><h4 id=call_framego>call_frame.go</h4><p><code>call_frame.go</code> 中定义了 <code>CallFrame</code> 结构体，相当于一个调用栈</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>CallFrame</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=c1>// Cache this State wraps
</span><span class=c1></span>	<span class=o>*</span><span class=nx>acmstate</span><span class=p>.</span><span class=nx>Cache</span>
	<span class=c1>// Where we sync
</span><span class=c1></span>	<span class=nx>backend</span> <span class=nx>acmstate</span><span class=p>.</span><span class=nx>ReaderWriter</span>
	<span class=c1>// In order for nested cache to inherit any options
</span><span class=c1></span>	<span class=nx>cacheOptions</span> <span class=p>[]</span><span class=nx>acmstate</span><span class=p>.</span><span class=nx>CacheOption</span>
	<span class=c1>// Depth of the call stack
</span><span class=c1></span>	<span class=nx>callStackDepth</span> <span class=kt>uint64</span>
	<span class=c1>// Max call stack depth
</span><span class=c1></span>	<span class=nx>maxCallStackDepth</span> <span class=kt>uint64</span>
<span class=p>}</span>

<span class=c1>// Create a new CallFrame to hold state updates at a particular level in the call stack
</span><span class=c1></span><span class=kd>func</span> <span class=nf>NewCallFrame</span><span class=p>(</span><span class=nx>st</span> <span class=nx>acmstate</span><span class=p>.</span><span class=nx>ReaderWriter</span><span class=p>,</span> <span class=nx>cacheOptions</span> <span class=o>...</span><span class=nx>acmstate</span><span class=p>.</span><span class=nx>CacheOption</span><span class=p>)</span> <span class=o>*</span><span class=nx>CallFrame</span> <span class=p>{</span>
	<span class=k>return</span> <span class=nf>newCallFrame</span><span class=p>(</span><span class=nx>st</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>cacheOptions</span><span class=o>...</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>newCallFrame</span><span class=p>(</span><span class=nx>st</span> <span class=nx>acmstate</span><span class=p>.</span><span class=nx>ReaderWriter</span><span class=p>,</span> <span class=nx>stackDepth</span> <span class=kt>uint64</span><span class=p>,</span> <span class=nx>maxCallStackDepth</span> <span class=kt>uint64</span><span class=p>,</span> <span class=nx>cacheOptions</span> <span class=o>...</span><span class=nx>acmstate</span><span class=p>.</span><span class=nx>CacheOption</span><span class=p>)</span> <span class=o>*</span><span class=nx>CallFrame</span> <span class=p>{</span>
	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>CallFrame</span><span class=p>{</span>
		<span class=nx>Cache</span><span class=p>:</span>             <span class=nx>acmstate</span><span class=p>.</span><span class=nf>NewCache</span><span class=p>(</span><span class=nx>st</span><span class=p>,</span> <span class=nx>cacheOptions</span><span class=o>...</span><span class=p>),</span>
		<span class=nx>backend</span><span class=p>:</span>           <span class=nx>st</span><span class=p>,</span>
		<span class=nx>cacheOptions</span><span class=p>:</span>      <span class=nx>cacheOptions</span><span class=p>,</span>
		<span class=nx>callStackDepth</span><span class=p>:</span>    <span class=nx>stackDepth</span><span class=p>,</span>
		<span class=nx>maxCallStackDepth</span><span class=p>:</span> <span class=nx>maxCallStackDepth</span><span class=p>,</span>
	<span class=p>}</span>
<span class=p>}</span>

<span class=o>...</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>st</span> <span class=o>*</span><span class=nx>CallFrame</span><span class=p>)</span> <span class=nf>NewFrame</span><span class=p>(</span><span class=nx>cacheOptions</span> <span class=o>...</span><span class=nx>acmstate</span><span class=p>.</span><span class=nx>CacheOption</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>CallFrame</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=k>if</span> <span class=nx>st</span><span class=p>.</span><span class=nx>maxCallStackDepth</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>st</span><span class=p>.</span><span class=nx>maxCallStackDepth</span> <span class=o>==</span> <span class=nx>st</span><span class=p>.</span><span class=nx>callStackDepth</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>errors</span><span class=p>.</span><span class=nx>Codes</span><span class=p>.</span><span class=nx>CallStackOverflow</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=nf>newCallFrame</span><span class=p>(</span><span class=nx>st</span><span class=p>.</span><span class=nx>Cache</span><span class=p>,</span> <span class=nx>st</span><span class=p>.</span><span class=nx>callStackDepth</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=nx>st</span><span class=p>.</span><span class=nx>maxCallStackDepth</span><span class=p>,</span>
		<span class=nb>append</span><span class=p>(</span><span class=nx>st</span><span class=p>.</span><span class=nx>cacheOptions</span><span class=p>,</span> <span class=nx>cacheOptions</span><span class=o>...</span><span class=p>)</span><span class=o>...</span><span class=p>),</span> <span class=kc>nil</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>st</span> <span class=o>*</span><span class=nx>CallFrame</span><span class=p>)</span> <span class=nf>Sync</span><span class=p>()</span> <span class=kt>error</span> <span class=p>{</span>
	<span class=nx>err</span> <span class=o>:=</span> <span class=nx>st</span><span class=p>.</span><span class=nx>Cache</span><span class=p>.</span><span class=nf>Sync</span><span class=p>(</span><span class=nx>st</span><span class=p>.</span><span class=nx>backend</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>AsException</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>NewCallFrame函数暴露给外界用于创建新的CallFrame，该函数接受两个参数：实现了ReaderWriter接口的类型和任意多个CacheOption，并调用内部函数nameCallFrame来创建CallFrame</p><p>newCallFrame会根据传入的参数创建一个<a href=#state_cachego rel>Cache</a>，用于缓存账户及存储信息</p><p>使用NewFrame创建新的CallFrame时，会继承当前CallFrame的值，并将当前栈高度值加一，使其看起来就像在调用栈中压入了一个新的调用</p><p>CallFrame包含一个Sync方法，用于将缓存写回，其内部会调用<a href=#state_cachego rel>Cache</a>的Sync()方法执行写回操作</p><h4 id=callgo>call.go</h4><p>call.go中实现了一个Call函数，为所有Callable.Call接口的实现类型提供了一层封装：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// Call provides a standard wrapper for implementing Callable.Call with appropriate error handling and event firing.
</span><span class=c1></span><span class=kd>func</span> <span class=nf>Call</span><span class=p>(</span><span class=nx>state</span> <span class=nx>State</span><span class=p>,</span> <span class=nx>params</span> <span class=nx>CallParams</span><span class=p>,</span> <span class=nx>execute</span> <span class=kd>func</span><span class=p>(</span><span class=nx>State</span><span class=p>,</span> <span class=nx>CallParams</span><span class=p>)</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>))</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>maybe</span> <span class=o>:=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>errors</span><span class=p>.</span><span class=nx>Maybe</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>params</span><span class=p>.</span><span class=nx>CallType</span> <span class=o>==</span> <span class=nx>exec</span><span class=p>.</span><span class=nx>CallTypeCall</span> <span class=o>||</span> <span class=nx>params</span><span class=p>.</span><span class=nx>CallType</span> <span class=o>==</span> <span class=nx>exec</span><span class=p>.</span><span class=nx>CallTypeCode</span> <span class=p>{</span>
		<span class=c1>// NOTE: Delegate and Static CallTypes do not transfer the value to the callee.
</span><span class=c1></span>		<span class=nx>maybe</span><span class=p>.</span><span class=nf>PushError</span><span class=p>(</span><span class=nf>Transfer</span><span class=p>(</span><span class=nx>state</span><span class=p>.</span><span class=nx>CallFrame</span><span class=p>,</span> <span class=nx>params</span><span class=p>.</span><span class=nx>Caller</span><span class=p>,</span> <span class=nx>params</span><span class=p>.</span><span class=nx>Callee</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>params</span><span class=p>.</span><span class=nx>Value</span><span class=p>))</span>
	<span class=p>}</span>

	<span class=nx>output</span> <span class=o>:=</span> <span class=nx>maybe</span><span class=p>.</span><span class=nf>Bytes</span><span class=p>(</span><span class=nf>execute</span><span class=p>(</span><span class=nx>state</span><span class=p>,</span> <span class=nx>params</span><span class=p>))</span>
	<span class=c1>// fire the post call event (including exception if applicable) and make sure we return the accumulated call error
</span><span class=c1></span>	<span class=nx>maybe</span><span class=p>.</span><span class=nf>PushError</span><span class=p>(</span><span class=nf>FireCallEvent</span><span class=p>(</span><span class=nx>state</span><span class=p>.</span><span class=nx>CallFrame</span><span class=p>,</span> <span class=nx>maybe</span><span class=p>.</span><span class=nf>Error</span><span class=p>(),</span> <span class=nx>state</span><span class=p>.</span><span class=nx>EventSink</span><span class=p>,</span> <span class=nx>output</span><span class=p>,</span> <span class=nx>params</span><span class=p>))</span>
	<span class=k>return</span> <span class=nx>output</span><span class=p>,</span> <span class=nx>maybe</span><span class=p>.</span><span class=nf>Error</span><span class=p>()</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>其中第三个参数execute就是定义了具体的执行过程的函数，在burrow中，合约调用/原生合约/原生函数/wasm调用都定义了特定的执行函数，在实现<a href=#callablego rel>Callable.Call</a>接口时调用上面的Call函数，并将特定的执行函数作为第三个参数传入</p><p>由该函数可以看出合约调用的一般流程：修改交易双方账户余额&ndash;执行合约&ndash;记录事件</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>CallFromSite</span><span class=p>(</span><span class=nx>st</span> <span class=nx>State</span><span class=p>,</span> <span class=nx>dispatcher</span> <span class=nx>Dispatcher</span><span class=p>,</span> <span class=nx>site</span> <span class=nx>CallParams</span><span class=p>,</span> <span class=nx>target</span> <span class=nx>CallParams</span><span class=p>)</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>err</span> <span class=o>:=</span> <span class=nf>EnsurePermission</span><span class=p>(</span><span class=nx>st</span><span class=p>.</span><span class=nx>CallFrame</span><span class=p>,</span> <span class=nx>site</span><span class=p>.</span><span class=nx>Callee</span><span class=p>,</span> <span class=nx>permission</span><span class=p>.</span><span class=nx>Call</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
	<span class=p>}</span>
	<span class=c1>// Get the arguments from the memory
</span><span class=c1></span>	<span class=c1>// EVM contract
</span><span class=c1></span>	<span class=nx>err</span> <span class=p>=</span> <span class=nf>UseGasNegative</span><span class=p>(</span><span class=nx>site</span><span class=p>.</span><span class=nx>Gas</span><span class=p>,</span> <span class=nx>GasGetAccount</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
	<span class=p>}</span>
	<span class=c1>// since CALL is used also for sending funds,
</span><span class=c1></span>	<span class=c1>// acc may not exist yet. This is an errors.CodedError for
</span><span class=c1></span>	<span class=c1>// CALLCODE, but not for CALL, though I don&#39;t think
</span><span class=c1></span>	<span class=c1>// ethereum actually cares
</span><span class=c1></span>	<span class=nx>acc</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>st</span><span class=p>.</span><span class=nx>CallFrame</span><span class=p>.</span><span class=nf>GetAccount</span><span class=p>(</span><span class=nx>target</span><span class=p>.</span><span class=nx>Callee</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
	<span class=p>}</span>
	<span class=k>if</span> <span class=nx>acc</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>if</span> <span class=nx>target</span><span class=p>.</span><span class=nx>CallType</span> <span class=o>!=</span> <span class=nx>exec</span><span class=p>.</span><span class=nx>CallTypeCall</span> <span class=p>{</span>
			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>errors</span><span class=p>.</span><span class=nx>Codes</span><span class=p>.</span><span class=nx>UnknownAddress</span>
		<span class=p>}</span>
		<span class=c1>// We&#39;re sending funds to a new account so we must create it first
</span><span class=c1></span>		<span class=nx>err</span> <span class=o>:=</span> <span class=nx>st</span><span class=p>.</span><span class=nx>CallFrame</span><span class=p>.</span><span class=nf>CreateAccount</span><span class=p>(</span><span class=nx>site</span><span class=p>.</span><span class=nx>Callee</span><span class=p>,</span> <span class=nx>target</span><span class=p>.</span><span class=nx>Callee</span><span class=p>)</span>
		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
		<span class=p>}</span>
		<span class=nx>acc</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>st</span><span class=p>.</span><span class=nx>CallFrame</span><span class=p>.</span><span class=nf>GetAccount</span><span class=p>(</span><span class=nx>target</span><span class=p>.</span><span class=nx>Callee</span><span class=p>)</span>
		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
		<span class=p>}</span>
	<span class=p>}</span>

	<span class=c1>// Establish a stack frame and perform the call
</span><span class=c1></span>	<span class=nx>childCallFrame</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>st</span><span class=p>.</span><span class=nx>CallFrame</span><span class=p>.</span><span class=nf>NewFrame</span><span class=p>()</span>
	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
	<span class=p>}</span>
	<span class=nx>childState</span> <span class=o>:=</span> <span class=nx>State</span><span class=p>{</span>
		<span class=nx>CallFrame</span><span class=p>:</span>  <span class=nx>childCallFrame</span><span class=p>,</span>
		<span class=nx>Blockchain</span><span class=p>:</span> <span class=nx>st</span><span class=p>.</span><span class=nx>Blockchain</span><span class=p>,</span>
		<span class=nx>EventSink</span><span class=p>:</span>  <span class=nx>st</span><span class=p>.</span><span class=nx>EventSink</span><span class=p>,</span>
	<span class=p>}</span>
	<span class=c1>// Ensure that gasLimit is reasonable
</span><span class=c1></span>	<span class=k>if</span> <span class=nx>site</span><span class=p>.</span><span class=nx>Gas</span><span class=p>.</span><span class=nf>Cmp</span><span class=p>(</span><span class=nx>target</span><span class=p>.</span><span class=nx>Gas</span><span class=p>)</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=c1>// EIP150 - the 63/64 rule - rather than errors.CodedError we pass this specified fraction of the total available gas
</span><span class=c1></span>		<span class=nx>gas</span> <span class=o>:=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>big</span><span class=p>.</span><span class=nx>Int</span><span class=p>)</span>
		<span class=nx>target</span><span class=p>.</span><span class=nx>Gas</span><span class=p>.</span><span class=nf>Sub</span><span class=p>(</span><span class=nx>site</span><span class=p>.</span><span class=nx>Gas</span><span class=p>,</span> <span class=nx>gas</span><span class=p>.</span><span class=nf>Div</span><span class=p>(</span><span class=nx>site</span><span class=p>.</span><span class=nx>Gas</span><span class=p>,</span> <span class=nx>big64</span><span class=p>))</span>
	<span class=p>}</span>
	<span class=c1>// NOTE: we will return any used gas later.
</span><span class=c1></span>	<span class=nx>site</span><span class=p>.</span><span class=nx>Gas</span><span class=p>.</span><span class=nf>Sub</span><span class=p>(</span><span class=nx>site</span><span class=p>.</span><span class=nx>Gas</span><span class=p>,</span> <span class=nx>target</span><span class=p>.</span><span class=nx>Gas</span><span class=p>)</span>

	<span class=c1>// Setup callee params for call type
</span><span class=c1></span>	<span class=nx>target</span><span class=p>.</span><span class=nx>Origin</span> <span class=p>=</span> <span class=nx>site</span><span class=p>.</span><span class=nx>Origin</span>

	<span class=c1>// Set up the caller/callee context
</span><span class=c1></span>	<span class=k>switch</span> <span class=nx>target</span><span class=p>.</span><span class=nx>CallType</span> <span class=p>{</span>
	<span class=k>case</span> <span class=nx>exec</span><span class=p>.</span><span class=nx>CallTypeCall</span><span class=p>:</span>
		<span class=c1>// Calls contract at target from this contract normally
</span><span class=c1></span>		<span class=c1>// Value: transferred
</span><span class=c1></span>		<span class=c1>// Caller: this contract
</span><span class=c1></span>		<span class=c1>// Storage: target
</span><span class=c1></span>		<span class=c1>// Code: from target
</span><span class=c1></span>		<span class=nx>target</span><span class=p>.</span><span class=nx>Caller</span> <span class=p>=</span> <span class=nx>site</span><span class=p>.</span><span class=nx>Callee</span>

	<span class=k>case</span> <span class=nx>exec</span><span class=p>.</span><span class=nx>CallTypeStatic</span><span class=p>:</span>
		<span class=c1>// Calls contract at target from this contract with no state mutation
</span><span class=c1></span>		<span class=c1>// Value: not transferred
</span><span class=c1></span>		<span class=c1>// Caller: this contract
</span><span class=c1></span>		<span class=c1>// Storage: target (read-only)
</span><span class=c1></span>		<span class=c1>// Code: from target
</span><span class=c1></span>		<span class=nx>target</span><span class=p>.</span><span class=nx>Caller</span> <span class=p>=</span> <span class=nx>site</span><span class=p>.</span><span class=nx>Callee</span>

		<span class=nx>childState</span><span class=p>.</span><span class=nx>CallFrame</span><span class=p>.</span><span class=nf>ReadOnly</span><span class=p>()</span>
		<span class=nx>childState</span><span class=p>.</span><span class=nx>EventSink</span> <span class=p>=</span> <span class=nx>exec</span><span class=p>.</span><span class=nf>NewLogFreeEventSink</span><span class=p>(</span><span class=nx>childState</span><span class=p>.</span><span class=nx>EventSink</span><span class=p>)</span>

	<span class=k>case</span> <span class=nx>exec</span><span class=p>.</span><span class=nx>CallTypeCode</span><span class=p>:</span>
		<span class=c1>// Calling this contract from itself as if it had the code at target
</span><span class=c1></span>		<span class=c1>// Value: transferred
</span><span class=c1></span>		<span class=c1>// Caller: this contract
</span><span class=c1></span>		<span class=c1>// Storage: this contract
</span><span class=c1></span>		<span class=c1>// Code: from target
</span><span class=c1></span>
		<span class=nx>target</span><span class=p>.</span><span class=nx>Caller</span> <span class=p>=</span> <span class=nx>site</span><span class=p>.</span><span class=nx>Callee</span>
		<span class=nx>target</span><span class=p>.</span><span class=nx>Callee</span> <span class=p>=</span> <span class=nx>site</span><span class=p>.</span><span class=nx>Callee</span>

	<span class=k>case</span> <span class=nx>exec</span><span class=p>.</span><span class=nx>CallTypeDelegate</span><span class=p>:</span>
		<span class=c1>// Calling this contract from the original caller as if it had the code at target
</span><span class=c1></span>		<span class=c1>// Value: not transferred
</span><span class=c1></span>		<span class=c1>// Caller: original caller
</span><span class=c1></span>		<span class=c1>// Storage: this contract
</span><span class=c1></span>		<span class=c1>// Code: from target
</span><span class=c1></span>
		<span class=nx>target</span><span class=p>.</span><span class=nx>Caller</span> <span class=p>=</span> <span class=nx>site</span><span class=p>.</span><span class=nx>Caller</span>
		<span class=nx>target</span><span class=p>.</span><span class=nx>Callee</span> <span class=p>=</span> <span class=nx>site</span><span class=p>.</span><span class=nx>Callee</span>

	<span class=k>default</span><span class=p>:</span>
		<span class=c1>// Switch should be exhaustive so we should reach this
</span><span class=c1></span>		<span class=nb>panic</span><span class=p>(</span><span class=s>&#34;invalid call type&#34;</span><span class=p>)</span>
	<span class=p>}</span>

	<span class=nx>dispatch</span> <span class=o>:=</span> <span class=nx>dispatcher</span><span class=p>.</span><span class=nf>Dispatch</span><span class=p>(</span><span class=nx>acc</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>dispatch</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=nx>errors</span><span class=p>.</span><span class=nx>Codes</span><span class=p>.</span><span class=nx>NotCallable</span><span class=p>,</span> <span class=s>&#34;cannot call: %v&#34;</span><span class=p>,</span> <span class=nx>acc</span><span class=p>.</span><span class=nx>Address</span><span class=p>)</span>
	<span class=p>}</span>
	<span class=nx>returnData</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dispatch</span><span class=p>.</span><span class=nf>Call</span><span class=p>(</span><span class=nx>childState</span><span class=p>,</span> <span class=nx>target</span><span class=p>)</span>

	<span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=c1>// Sync error is a hard stop
</span><span class=c1></span>		<span class=nx>err</span> <span class=p>=</span> <span class=nx>childState</span><span class=p>.</span><span class=nx>CallFrame</span><span class=p>.</span><span class=nf>Sync</span><span class=p>()</span>
	<span class=p>}</span>

	<span class=c1>// Handle remaining gas.
</span><span class=c1></span>	<span class=c1>//site.Gas.Add(site.Gas, target.Gas)
</span><span class=c1></span>	<span class=k>return</span> <span class=nx>returnData</span><span class=p>,</span> <span class=nx>err</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>CallFromSite在执行合约代码中的CALL/CALLCODE/DELEGATECALL/STATICCALL指令时被调用，用于由合约代码创建新的合约账户，其执行流程大致如下：</p><p>调用<a href=#accountsgo rel>EnsurePermission</a>检查当前合约是否拥有创建合约的权限 &ndash; 减去创建账户需要消耗的gas值 &ndash; 检查目标账户是否存在，若不存在，则根据调用类型选择创建新账户或是报错 &ndash; 调用<a href=#call_framego rel>NewFrame</a>创建一个childCallFrame &ndash; 由childCallFrame创建childState &ndash; 检查gas值 &ndash; 根据调用类型设置目标账户参数 &ndash; 调用dispatcher.Diapatch方法返回一个<a href=#callablego rel>Callable</a>实现类型 &ndash; 调用Call方法执行 &ndash; 调用<a href=#call_framego rel>Sync</a>方法写回账户状态</p><p>这里的dispatcher实际为<a href=#evmgo rel>EVM</a>中的externalDispatcher</p><h4 id=callablego>callable.go</h4><p><code>callable.go</code> 中定义了合约调用/evm执行所需的一些参数和接口</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>Blockchain</span> <span class=kd>interface</span> <span class=p>{</span>
	<span class=nf>LastBlockHeight</span><span class=p>()</span> <span class=kt>uint64</span>
	<span class=nf>LastBlockTime</span><span class=p>()</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span>
	<span class=nf>BlockHash</span><span class=p>(</span><span class=nx>height</span> <span class=kt>uint64</span><span class=p>)</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
	<span class=nf>ChainID</span><span class=p>()</span> <span class=kt>string</span>
<span class=p>}</span>

<span class=kd>type</span> <span class=nx>CallParams</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>CallType</span> <span class=nx>exec</span><span class=p>.</span><span class=nx>CallType</span>    <span class=c1>//调用类型：Call CallCode DelegateCall StaticCall
</span><span class=c1></span>	<span class=nx>Origin</span>   <span class=nx>crypto</span><span class=p>.</span><span class=nx>Address</span>
	<span class=nx>Caller</span>   <span class=nx>crypto</span><span class=p>.</span><span class=nx>Address</span>
	<span class=nx>Callee</span>   <span class=nx>crypto</span><span class=p>.</span><span class=nx>Address</span>
	<span class=nx>Input</span>    <span class=p>[]</span><span class=kt>byte</span>
	<span class=nx>Value</span>    <span class=nx>big</span><span class=p>.</span><span class=nx>Int</span>
	<span class=nx>Gas</span>      <span class=o>*</span><span class=nx>big</span><span class=p>.</span><span class=nx>Int</span>
<span class=p>}</span>

<span class=kd>type</span> <span class=nx>Callable</span> <span class=kd>interface</span> <span class=p>{</span>
	<span class=nf>Call</span><span class=p>(</span><span class=nx>state</span> <span class=nx>State</span><span class=p>,</span> <span class=nx>params</span> <span class=nx>CallParams</span><span class=p>)</span> <span class=p>(</span><span class=nx>output</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p><code>Blockchain</code> 接口用于获取区块链相关信息，<code>CallParams</code> 结构体，表示执行智能合约所需的参数，它们用于evm的执行过程</p><p>//TODO
<code>Callable</code> 接口，仅包含一个 <code>Call</code> 函数，合约调用/原生合约/原生函数/wasm调用都需要实现该接口，实现了该接口的类型有<a href=#evmgo rel>evm contract</a>、<a href=#contractgo rel>native contract</a>、<a href rel>wasm contract</a></p><h4 id=dispatchergo>dispatcher.go</h4><p><code>dispatcher.go</code> 中定义了dispatcher的相关接口和函数，用于evm/wasm/native contract之间的相互调用</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>Dispatcher</span> <span class=kd>interface</span> <span class=p>{</span>
	<span class=c1>// If this Dispatcher is capable of dispatching this account (e.g. if it has the correct bytecode) then return a
</span><span class=c1></span>	<span class=c1>// Callable that wraps the function, otherwise return nil
</span><span class=c1></span>	<span class=nf>Dispatch</span><span class=p>(</span><span class=nx>acc</span> <span class=o>*</span><span class=nx>acm</span><span class=p>.</span><span class=nx>Account</span><span class=p>)</span> <span class=nx>Callable</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Dispatcher接口包含一个Dispatch函数，它接收一个账户类型作为参数，返回一个实现了<a href=#callablego rel>Callable</a>接口的类型，也就是合约/原生合约/原生函数/wasm，具体返回那种类型会根据传入的地址进行判定</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// An ExternalDispatcher is able to Dispatch accounts to external engines as well as Dispatch to itself
</span><span class=c1></span><span class=kd>type</span> <span class=nx>ExternalDispatcher</span> <span class=kd>interface</span> <span class=p>{</span>
	<span class=nx>Dispatcher</span>
	<span class=nf>SetExternals</span><span class=p>(</span><span class=nx>externals</span> <span class=nx>Dispatcher</span><span class=p>)</span>
<span class=p>}</span>

<span class=c1>// An ExternalDispatcher is able to Dispatch accounts to external engines as well as Dispatch to itself
</span><span class=c1>// 包含接口的结构体类型在初始化时需要传入一个实现了该接口的类型进行赋值
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Externals</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=c1>// Provide any foreign dispatchers to allow calls between VMs
</span><span class=c1></span>	<span class=nx>externals</span> <span class=nx>Dispatcher</span>
<span class=p>}</span>

<span class=c1>//用于确认Externals是否实现了ExternalDispatcher接口
</span><span class=c1></span><span class=kd>var</span> <span class=nx>_</span> <span class=nx>ExternalDispatcher</span> <span class=p>=</span> <span class=p>(</span><span class=o>*</span><span class=nx>Externals</span><span class=p>)(</span><span class=kc>nil</span><span class=p>)</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>ed</span> <span class=o>*</span><span class=nx>Externals</span><span class=p>)</span> <span class=nf>Dispatch</span><span class=p>(</span><span class=nx>acc</span> <span class=o>*</span><span class=nx>acm</span><span class=p>.</span><span class=nx>Account</span><span class=p>)</span> <span class=nx>Callable</span> <span class=p>{</span>
	<span class=c1>// Try external calls then fallback to EVM
</span><span class=c1></span>	<span class=k>if</span> <span class=nx>ed</span><span class=p>.</span><span class=nx>externals</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=nx>ed</span><span class=p>.</span><span class=nx>externals</span><span class=p>.</span><span class=nf>Dispatch</span><span class=p>(</span><span class=nx>acc</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>ed</span> <span class=o>*</span><span class=nx>Externals</span><span class=p>)</span> <span class=nf>SetExternals</span><span class=p>(</span><span class=nx>externals</span> <span class=nx>Dispatcher</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>ed</span><span class=p>.</span><span class=nx>externals</span> <span class=p>=</span> <span class=nx>externals</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>ExternalDispatcher接口包含了一个Dispatcher和一个用于设置Dispatcher的SetExternals函数，<a href=#evmgo rel>EVM</a>中包含了一个匿名Externals类型，用于设置WASM</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>Dispatchers</span> <span class=p>[]</span><span class=nx>Dispatcher</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>ds</span> <span class=nx>Dispatchers</span><span class=p>)</span> <span class=nf>Dispatch</span><span class=p>(</span><span class=nx>acc</span> <span class=o>*</span><span class=nx>acm</span><span class=p>.</span><span class=nx>Account</span><span class=p>)</span> <span class=nx>Callable</span> <span class=p>{</span>
	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>d</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>ds</span> <span class=p>{</span>
		<span class=nx>callable</span> <span class=o>:=</span> <span class=nx>d</span><span class=p>.</span><span class=nf>Dispatch</span><span class=p>(</span><span class=nx>acc</span><span class=p>)</span>
		<span class=k>if</span> <span class=nx>callable</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nx>callable</span>
		<span class=p>}</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Dispatchers类型实际为Dispatcher切片，它的Dispatch方法会遍历切片中保存的所有Dispatcher，并返回一个有效的Callable实现类型，由于账户地址是唯一的，也就是一个账户不可能既对应一个native contract，又对应一般的合约，因此Dispatchers中的顺序不重要，即在Dispatcher非空的情况下，只能返回零个或一个Callable</p><div class="details admonition note open"><div class="details-summary admonition-title"><i class="icon fas fa-pencil-alt fa-fw"></i>think<i class="details-icon fas fa-angle-right fa-fw"></i></div><div class=details-content><div class=admonition-content>Dispatcher根据地址获取Callable实现类型，Callable中的call函数定义了具体的执行过程，也就是说，不同的执行引擎EVM、Native、WASM可以使用相同的调用流程完成调用</div></div></div><h4 id=gasgo>gas.go</h4><p><code>gas.go</code> 中定义了各种操作需要消耗的gas值以及计算gas值的函数，在burrow中，操作消耗的gas值均为1</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>const</span> <span class=p>(</span>
	<span class=nx>GasSha3</span>          <span class=kt>uint64</span> <span class=p>=</span> <span class=mi>1</span>
	<span class=nx>GasGetAccount</span>    <span class=kt>uint64</span> <span class=p>=</span> <span class=mi>1</span>
	<span class=nx>GasStorageUpdate</span> <span class=kt>uint64</span> <span class=p>=</span> <span class=mi>1</span>
	<span class=nx>GasCreateAccount</span> <span class=kt>uint64</span> <span class=p>=</span> <span class=mi>1</span>

	<span class=nx>GasBaseOp</span>  <span class=kt>uint64</span> <span class=p>=</span> <span class=mi>0</span> <span class=c1>// TODO: make this 1
</span><span class=c1></span>	<span class=nx>GasStackOp</span> <span class=kt>uint64</span> <span class=p>=</span> <span class=mi>1</span>

	<span class=nx>GasEcRecover</span>     <span class=kt>uint64</span> <span class=p>=</span> <span class=mi>1</span>
	<span class=nx>GasSha256Word</span>    <span class=kt>uint64</span> <span class=p>=</span> <span class=mi>1</span>
	<span class=nx>GasSha256Base</span>    <span class=kt>uint64</span> <span class=p>=</span> <span class=mi>1</span>
	<span class=nx>GasRipemd160Word</span> <span class=kt>uint64</span> <span class=p>=</span> <span class=mi>1</span>
	<span class=nx>GasRipemd160Base</span> <span class=kt>uint64</span> <span class=p>=</span> <span class=mi>1</span>
	<span class=nx>GasExpModWord</span>    <span class=kt>uint64</span> <span class=p>=</span> <span class=mi>1</span>
	<span class=nx>GasExpModBase</span>    <span class=kt>uint64</span> <span class=p>=</span> <span class=mi>1</span>
	<span class=nx>GasIdentityWord</span>  <span class=kt>uint64</span> <span class=p>=</span> <span class=mi>1</span>
	<span class=nx>GasIdentityBase</span>  <span class=kt>uint64</span> <span class=p>=</span> <span class=mi>1</span>
<span class=p>)</span>

<span class=c1>// Try to deduct gasToUse from gasLeft.  If ok return false, otherwise
</span><span class=c1>// set err and return true.
</span><span class=c1></span><span class=kd>func</span> <span class=nf>UseGasNegative</span><span class=p>(</span><span class=nx>gasLeft</span> <span class=o>*</span><span class=nx>big</span><span class=p>.</span><span class=nx>Int</span><span class=p>,</span> <span class=nx>gasToUse</span> <span class=kt>uint64</span><span class=p>)</span> <span class=nx>errors</span><span class=p>.</span><span class=nx>CodedError</span> <span class=p>{</span>
	<span class=nx>delta</span> <span class=o>:=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>big</span><span class=p>.</span><span class=nx>Int</span><span class=p>).</span><span class=nf>SetUint64</span><span class=p>(</span><span class=nx>gasToUse</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>gasLeft</span><span class=p>.</span><span class=nf>Cmp</span><span class=p>(</span><span class=nx>delta</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=nx>gasLeft</span><span class=p>.</span><span class=nf>Sub</span><span class=p>(</span><span class=nx>gasLeft</span><span class=p>,</span> <span class=nx>delta</span><span class=p>)</span>
	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nx>Codes</span><span class=p>.</span><span class=nx>InsufficientGas</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h4 id=enginenativesgo>engine/natives.go</h4><p><code>natives.go</code> 中定义了原生合约相关的接口</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>Native</span> <span class=kd>interface</span> <span class=p>{</span>
	<span class=nx>Callable</span>
	<span class=nf>SetExternals</span><span class=p>(</span><span class=nx>externals</span> <span class=nx>Dispatcher</span><span class=p>)</span>
	<span class=nf>ContractMeta</span><span class=p>()</span> <span class=p>[]</span><span class=o>*</span><span class=nx>acm</span><span class=p>.</span><span class=nx>ContractMeta</span>
	<span class=nf>FullName</span><span class=p>()</span> <span class=kt>string</span>
	<span class=nf>Address</span><span class=p>()</span> <span class=nx>crypto</span><span class=p>.</span><span class=nx>Address</span>
<span class=p>}</span>

<span class=kd>type</span> <span class=nx>Natives</span> <span class=kd>interface</span> <span class=p>{</span>
	<span class=nx>ExternalDispatcher</span>
	<span class=nf>GetByAddress</span><span class=p>(</span><span class=nx>address</span> <span class=nx>crypto</span><span class=p>.</span><span class=nx>Address</span><span class=p>)</span> <span class=nx>Native</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>原生合约/原生函数都实现了Native接口，Native接口中包含了一个<a href=#callablego rel>Callable</a>接口，即原生合约需要实现一个Call函数以供调用</p><p>package native中定义的<a href=#nativenativesgo rel>Natives</a>结构体类型实现了Natives接口，用于组织多个原生合约/原生函数</p><h4 id=optionsgo>options.go</h4><p><code>options.go</code> 中仅有一个Options结构体类型，它包含了创建evm实例所需要的参数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// Options are parameters that are generally stable across a burrow configuration.
</span><span class=c1>// Defaults will be used for any zero values.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Options</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>MemoryProvider</span>           <span class=kd>func</span><span class=p>(</span><span class=nx>errors</span><span class=p>.</span><span class=nx>Sink</span><span class=p>)</span> <span class=nx>Memory</span>  <span class=c1>//返回一个实现了Memory接口的类型用于内存读写,默认为dynamicMemory
</span><span class=c1></span>	<span class=nx>Natives</span>                  <span class=nx>Natives</span>                   <span class=c1>//原生合约或者原生函数，在burrow中的默认为账户权限操作和加密操作相关实现
</span><span class=c1></span>	<span class=nx>Nonce</span>                    <span class=p>[]</span><span class=kt>byte</span>
	<span class=nx>DebugOpcodes</span>             <span class=kt>bool</span>                      <span class=c1>//是否为debug模式
</span><span class=c1></span>	<span class=nx>DumpTokens</span>               <span class=kt>bool</span>
	<span class=nx>CallStackMaxDepth</span>        <span class=kt>uint64</span>                    <span class=c1>//调用栈深度，用于初始化CallFrame
</span><span class=c1></span>	<span class=nx>DataStackInitialCapacity</span> <span class=kt>uint64</span>                    <span class=c1>//数据栈容量，用于初始化Stack，表示Stack中创建的切片的容量
</span><span class=c1></span>	<span class=nx>DataStackMaxDepth</span>        <span class=kt>uint64</span>                    <span class=c1>//数据栈深度，用于初始化Stack
</span><span class=c1></span>	<span class=nx>Logger</span>                   <span class=o>*</span><span class=nx>logging</span><span class=p>.</span><span class=nx>Logger</span>           <span class=c1>//日志
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><h4 id=enginestatego>engine/state.go</h4><p><code>state.go</code> 中仅包含了一个State结构体类型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>State</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=o>*</span><span class=nx>CallFrame</span>
	<span class=nx>Blockchain</span>
	<span class=nx>exec</span><span class=p>.</span><span class=nx>EventSink</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>State中包含三个字段：Callframe用于缓存状态以及对状态进行读写，Blockchain用于获取区块链信息，EventSink用于记录event</p><h3 id=evm>evm</h3><h4 id=abi>abi</h4><h5 id=abigo>abi.go</h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// Struct reflection
</span><span class=c1></span>
<span class=c1>// SpecFromStructReflect generates a FunctionSpec where the arguments and return values are
</span><span class=c1>// described a struct. Both args and rets should be set to the return value of reflect.TypeOf()
</span><span class=c1>// with the respective struct as an argument.
</span><span class=c1></span>
<span class=c1>//对结构体的每个字段都构造一个Arguement类型，用Arguement切片来表示一个结构体
</span><span class=c1></span><span class=kd>func</span> <span class=nf>SpecFromStructReflect</span><span class=p>(</span><span class=nx>fname</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>args</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Type</span><span class=p>,</span> <span class=nx>rets</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Type</span><span class=p>)</span> <span class=o>*</span><span class=nx>FunctionSpec</span> <span class=p>{</span>
	<span class=nx>inputs</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=nx>Argument</span><span class=p>,</span> <span class=nx>args</span><span class=p>.</span><span class=nf>NumField</span><span class=p>())</span>
	<span class=nx>outputs</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=nx>Argument</span><span class=p>,</span> <span class=nx>rets</span><span class=p>.</span><span class=nf>NumField</span><span class=p>())</span>

	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>args</span><span class=p>.</span><span class=nf>NumField</span><span class=p>();</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
		<span class=nx>f</span> <span class=o>:=</span> <span class=nx>args</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
		<span class=nx>a</span> <span class=o>:=</span> <span class=nf>typeFromReflect</span><span class=p>(</span><span class=nx>f</span><span class=p>.</span><span class=nx>Type</span><span class=p>)</span>
		<span class=nx>a</span><span class=p>.</span><span class=nx>Name</span> <span class=p>=</span> <span class=nx>f</span><span class=p>.</span><span class=nx>Name</span>
		<span class=nx>inputs</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>a</span>
	<span class=p>}</span>

	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>rets</span><span class=p>.</span><span class=nf>NumField</span><span class=p>();</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
		<span class=nx>f</span> <span class=o>:=</span> <span class=nx>rets</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
		<span class=nx>a</span> <span class=o>:=</span> <span class=nf>typeFromReflect</span><span class=p>(</span><span class=nx>f</span><span class=p>.</span><span class=nx>Type</span><span class=p>)</span>
		<span class=nx>a</span><span class=p>.</span><span class=nx>Name</span> <span class=p>=</span> <span class=nx>f</span><span class=p>.</span><span class=nx>Name</span>
		<span class=nx>outputs</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>a</span>
	<span class=p>}</span>

	<span class=k>return</span> <span class=nf>NewFunctionSpec</span><span class=p>(</span><span class=nx>fname</span><span class=p>,</span> <span class=nx>inputs</span><span class=p>,</span> <span class=nx>outputs</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>typeFromReflect</span><span class=p>(</span><span class=nx>v</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Type</span><span class=p>)</span> <span class=nx>Argument</span> <span class=p>{</span>
	<span class=nx>arg</span> <span class=o>:=</span> <span class=nx>Argument</span><span class=p>{</span><span class=nx>Name</span><span class=p>:</span> <span class=nx>v</span><span class=p>.</span><span class=nf>Name</span><span class=p>()}</span>

	<span class=k>if</span> <span class=nx>v</span> <span class=o>==</span> <span class=nx>reflect</span><span class=p>.</span><span class=nf>TypeOf</span><span class=p>(</span><span class=nx>crypto</span><span class=p>.</span><span class=nx>Address</span><span class=p>{})</span> <span class=p>{</span>
		<span class=nx>arg</span><span class=p>.</span><span class=nx>EVM</span> <span class=p>=</span> <span class=nx>EVMAddress</span><span class=p>{}</span>
	<span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>v</span> <span class=o>==</span> <span class=nx>reflect</span><span class=p>.</span><span class=nf>TypeOf</span><span class=p>(</span><span class=nx>big</span><span class=p>.</span><span class=nx>Int</span><span class=p>{})</span> <span class=p>{</span>
		<span class=nx>arg</span><span class=p>.</span><span class=nx>EVM</span> <span class=p>=</span> <span class=nx>EVMInt</span><span class=p>{</span><span class=nx>M</span><span class=p>:</span> <span class=mi>256</span><span class=p>}</span>
	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
		<span class=k>if</span> <span class=nx>v</span><span class=p>.</span><span class=nf>Kind</span><span class=p>()</span> <span class=o>==</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Array</span> <span class=p>{</span>
			<span class=c1>//如果v是Array类型，需要设置以下两个字段
</span><span class=c1></span>			<span class=nx>arg</span><span class=p>.</span><span class=nx>IsArray</span> <span class=p>=</span> <span class=kc>true</span>
			<span class=nx>arg</span><span class=p>.</span><span class=nx>ArrayLength</span> <span class=p>=</span> <span class=nb>uint64</span><span class=p>(</span><span class=nx>v</span><span class=p>.</span><span class=nf>Len</span><span class=p>())</span>
			<span class=c1>//将v设置为其存储的元素的类型
</span><span class=c1></span>			<span class=nx>v</span> <span class=p>=</span> <span class=nx>v</span><span class=p>.</span><span class=nf>Elem</span><span class=p>()</span>
		<span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>v</span><span class=p>.</span><span class=nf>Kind</span><span class=p>()</span> <span class=o>==</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Slice</span> <span class=p>{</span>
			<span class=nx>arg</span><span class=p>.</span><span class=nx>IsArray</span> <span class=p>=</span> <span class=kc>true</span>
			<span class=nx>v</span> <span class=p>=</span> <span class=nx>v</span><span class=p>.</span><span class=nf>Elem</span><span class=p>()</span>
		<span class=p>}</span>

		<span class=k>switch</span> <span class=nx>v</span><span class=p>.</span><span class=nf>Kind</span><span class=p>()</span> <span class=p>{</span>
		<span class=k>case</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Bool</span><span class=p>:</span>
			<span class=nx>arg</span><span class=p>.</span><span class=nx>EVM</span> <span class=p>=</span> <span class=nx>EVMBool</span><span class=p>{}</span>
		<span class=k>case</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>String</span><span class=p>:</span>
			<span class=nx>arg</span><span class=p>.</span><span class=nx>EVM</span> <span class=p>=</span> <span class=nx>EVMString</span><span class=p>{}</span>
		<span class=k>case</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Uint64</span><span class=p>:</span>
			<span class=nx>arg</span><span class=p>.</span><span class=nx>EVM</span> <span class=p>=</span> <span class=nx>EVMUint</span><span class=p>{</span><span class=nx>M</span><span class=p>:</span> <span class=mi>64</span><span class=p>}</span>
		<span class=k>case</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Int64</span><span class=p>:</span>
			<span class=nx>arg</span><span class=p>.</span><span class=nx>EVM</span> <span class=p>=</span> <span class=nx>EVMInt</span><span class=p>{</span><span class=nx>M</span><span class=p>:</span> <span class=mi>64</span><span class=p>}</span>
		<span class=k>default</span><span class=p>:</span>
			<span class=nb>panic</span><span class=p>(</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;no mapping for type %v&#34;</span><span class=p>,</span> <span class=nx>v</span><span class=p>.</span><span class=nf>Kind</span><span class=p>()))</span>
		<span class=p>}</span>
	<span class=p>}</span>

	<span class=k>return</span> <span class=nx>arg</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>SpecFromStructReflect函数接收两个reflect.Type类型，代表参数和返回值的类型，实际均为结构体类型，函数内部调用typeFromRelect函数对每个字段进行处理，将其转换为<a href=#event_specgo rel>Arguement</a>类型，根据字段的实际类型设置<a href=#primitivesgo rel>EVMType</a>实现类型，并保存至对应输入和输出的Arguement切片中，然后构造一个<a href=#function_specgo rel>FunctionSpec</a>类型并返回</p><h5 id=event_specgo>event_spec.go</h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// Argument is a decoded function parameter, return or event field
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Argument</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>Name</span>        <span class=kt>string</span>
	<span class=nx>EVM</span>         <span class=nx>EVMType</span>
	<span class=nx>IsArray</span>     <span class=kt>bool</span>
	<span class=nx>Indexed</span>     <span class=kt>bool</span>
	<span class=nx>Hashed</span>      <span class=kt>bool</span>
	<span class=nx>ArrayLength</span> <span class=kt>uint64</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Arguement类型被用于描述函数的参数/返回值或者event的输入，其中的EVM字段为<a href=#primitivesgo rel>EVMType</a>类型</p><h5 id=function_specgo>function_spec.go</h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// FunctionIDSize is the length of the function selector
</span><span class=c1></span><span class=kd>const</span> <span class=nx>FunctionIDSize</span> <span class=p>=</span> <span class=mi>4</span>

<span class=kd>type</span> <span class=nx>FunctionSpec</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>Name</span>       <span class=kt>string</span>
	<span class=nx>FunctionID</span> <span class=nx>FunctionID</span>
	<span class=nx>Constant</span>   <span class=kt>bool</span>
	<span class=nx>Inputs</span>     <span class=p>[]</span><span class=nx>Argument</span>
	<span class=nx>Outputs</span>    <span class=p>[]</span><span class=nx>Argument</span>
<span class=p>}</span>

<span class=kd>type</span> <span class=nx>FunctionID</span> <span class=p>[</span><span class=nx>FunctionIDSize</span><span class=p>]</span><span class=kt>byte</span>
</code></pre></td></tr></table></div></div><p>FunctionSpec类型定义了描述一个<a href=#functiongo rel>Function</a>需要的值，包括函数名、ID、输入的参数的类型和数量、输出的返回值的类型和数量，其中ID为固定4字节长度，输入与输出字段均为<a href=#event_specgo rel>Arguement</a>切片</p><h5 id=packinggo>packing.go</h5><p><code>packing.go</code> 中定义了编码/解码的具体函数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>Pack</span><span class=p>(</span><span class=nx>argSpec</span> <span class=p>[]</span><span class=nx>Argument</span><span class=p>,</span> <span class=nx>args</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>getArg</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>argGetter</span><span class=p>(</span><span class=nx>argSpec</span><span class=p>,</span> <span class=nx>args</span><span class=p>,</span> <span class=kc>false</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=nf>pack</span><span class=p>(</span><span class=nx>argSpec</span><span class=p>,</span> <span class=nx>getArg</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>Unpack</span><span class=p>(</span><span class=nx>argSpec</span> <span class=p>[]</span><span class=nx>Argument</span><span class=p>,</span> <span class=nx>data</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>args</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=kt>error</span> <span class=p>{</span>
	<span class=nx>getArg</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>argGetter</span><span class=p>(</span><span class=nx>argSpec</span><span class=p>,</span> <span class=nx>args</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>err</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=nf>unpack</span><span class=p>(</span><span class=nx>argSpec</span><span class=p>,</span> <span class=nx>data</span><span class=p>,</span> <span class=nx>getArg</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>argGetter</span><span class=p>(</span><span class=nx>argSpec</span> <span class=p>[]</span><span class=nx>Argument</span><span class=p>,</span> <span class=nx>args</span> <span class=p>[]</span><span class=kd>interface</span><span class=p>{},</span> <span class=nx>ptr</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=kd>interface</span><span class=p>{},</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>args</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span> <span class=p>{</span>
		<span class=nx>rv</span> <span class=o>:=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nf>ValueOf</span><span class=p>(</span><span class=nx>args</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
		<span class=k>if</span> <span class=nx>rv</span><span class=p>.</span><span class=nf>Kind</span><span class=p>()</span> <span class=o>==</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Ptr</span> <span class=p>{</span>
			<span class=nx>rv</span> <span class=p>=</span> <span class=nx>rv</span><span class=p>.</span><span class=nf>Elem</span><span class=p>()</span>
		<span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>ptr</span> <span class=p>{</span>
			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;struct pointer required in order to set values, but got %v&#34;</span><span class=p>,</span> <span class=nx>rv</span><span class=p>.</span><span class=nf>Kind</span><span class=p>())</span>
		<span class=p>}</span>
		<span class=k>if</span> <span class=nx>rv</span><span class=p>.</span><span class=nf>Kind</span><span class=p>()</span> <span class=o>!=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nx>Struct</span> <span class=p>{</span>
			<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>args</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span> <span class=p>{</span>
				<span class=c1>// Treat s single arg
</span><span class=c1></span>				<span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>{</span> <span class=k>return</span> <span class=nx>args</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>},</span> <span class=kc>nil</span>
			<span class=p>}</span>
			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;expected single argument to be struct but got %v&#34;</span><span class=p>,</span> <span class=nx>rv</span><span class=p>.</span><span class=nf>Kind</span><span class=p>())</span>
		<span class=p>}</span>
		<span class=nx>fields</span> <span class=o>:=</span> <span class=nx>rv</span><span class=p>.</span><span class=nf>NumField</span><span class=p>()</span>
		<span class=k>if</span> <span class=nx>fields</span> <span class=o>!=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>argSpec</span><span class=p>)</span> <span class=p>{</span>
			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;%d arguments in struct expected, %d received&#34;</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>argSpec</span><span class=p>),</span> <span class=nx>fields</span><span class=p>)</span>
		<span class=p>}</span>
		<span class=k>if</span> <span class=nx>ptr</span> <span class=p>{</span>
			<span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>{</span>
				<span class=k>return</span> <span class=nx>rv</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>).</span><span class=nf>Addr</span><span class=p>().</span><span class=nf>Interface</span><span class=p>()</span>
			<span class=p>},</span> <span class=kc>nil</span>
		<span class=p>}</span>
		<span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nx>rv</span><span class=p>.</span><span class=nf>Field</span><span class=p>(</span><span class=nx>i</span><span class=p>).</span><span class=nf>Interface</span><span class=p>()</span>
		<span class=p>},</span> <span class=kc>nil</span>
	<span class=p>}</span>
	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>args</span><span class=p>)</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=nx>argSpec</span><span class=p>)</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nx>args</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
		<span class=p>},</span> <span class=kc>nil</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;%d arguments expected, %d received&#34;</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>argSpec</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=nx>args</span><span class=p>))</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Pack、Unpack是对外暴露的函数</p><p>Unpack接收三个参数，argSpec为<a href=#event_specgo rel>Argument</a>切片类型，表示待解码数据的类型，data存储待解码的数据，args用来存储解码后的数据</p><p>argGetter返回一个函数 <code>func(int) interface{}</code> 用来为argSpec中的每个Argument分配一个储解码后的数据的类型，也就是argSpec和args的对应关系，如果二者长度相等，就是顺序对应，如果args长度为1，则判断其是否为结构体类型，若是则按照结构体字段顺序与argSpec对应，否则报错</p><p>Unpack调用argGetter函数获取用于返回与argSpec中每个Argument对应的类型的函数getArg，然后调用内部函数unpack</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>unpack</span><span class=p>(</span><span class=nx>argSpec</span> <span class=p>[]</span><span class=nx>Argument</span><span class=p>,</span> <span class=nx>data</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>getArg</span> <span class=kd>func</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>error</span> <span class=p>{</span>
	<span class=nx>offset</span> <span class=o>:=</span> <span class=mi>0</span>
	<span class=nx>offType</span> <span class=o>:=</span> <span class=nx>EVMInt</span><span class=p>{</span><span class=nx>M</span><span class=p>:</span> <span class=mi>64</span><span class=p>}</span>

	<span class=nx>getPrimitive</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>e</span> <span class=kd>interface</span><span class=p>{},</span> <span class=nx>a</span> <span class=nx>Argument</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
		<span class=k>if</span> <span class=nx>a</span><span class=p>.</span><span class=nx>EVM</span><span class=p>.</span><span class=nf>Dynamic</span><span class=p>()</span> <span class=p>{</span>
			<span class=kd>var</span> <span class=nx>o</span> <span class=kt>int64</span>
			<span class=nx>l</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>offType</span><span class=p>.</span><span class=nf>unpack</span><span class=p>(</span><span class=nx>data</span><span class=p>,</span> <span class=nx>offset</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>o</span><span class=p>)</span>
			<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
				<span class=k>return</span> <span class=nx>err</span>
			<span class=p>}</span>
			<span class=nx>offset</span> <span class=o>+=</span> <span class=nx>l</span>
			<span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>a</span><span class=p>.</span><span class=nx>EVM</span><span class=p>.</span><span class=nf>unpack</span><span class=p>(</span><span class=nx>data</span><span class=p>,</span> <span class=nb>int</span><span class=p>(</span><span class=nx>o</span><span class=p>),</span> <span class=nx>e</span><span class=p>)</span>
			<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
				<span class=k>return</span> <span class=nx>err</span>
			<span class=p>}</span>
		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
			<span class=nx>l</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>a</span><span class=p>.</span><span class=nx>EVM</span><span class=p>.</span><span class=nf>unpack</span><span class=p>(</span><span class=nx>data</span><span class=p>,</span> <span class=nx>offset</span><span class=p>,</span> <span class=nx>e</span><span class=p>)</span>
			<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
				<span class=k>return</span> <span class=nx>err</span>
			<span class=p>}</span>
			<span class=nx>offset</span> <span class=o>+=</span> <span class=nx>l</span>
		<span class=p>}</span>

		<span class=k>return</span> <span class=kc>nil</span>
	<span class=p>}</span>

	<span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>as</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>argSpec</span> <span class=p>{</span>
		<span class=k>if</span> <span class=nx>as</span><span class=p>.</span><span class=nx>Indexed</span> <span class=p>{</span>
			<span class=k>continue</span>
		<span class=p>}</span>

		<span class=nx>arg</span> <span class=o>:=</span> <span class=nf>getArg</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
		<span class=k>if</span> <span class=nx>as</span><span class=p>.</span><span class=nx>IsArray</span> <span class=p>{</span>
			<span class=kd>var</span> <span class=nx>array</span> <span class=o>*</span><span class=p>[]</span><span class=kd>interface</span><span class=p>{}</span>

			<span class=nx>array</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>arg</span><span class=p>.(</span><span class=o>*</span><span class=p>[]</span><span class=kd>interface</span><span class=p>{})</span>
			<span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
				<span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>arg</span><span class=p>.(</span><span class=o>*</span><span class=kt>string</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
					<span class=c1>// We have been asked to return the value as a string; make intermediate
</span><span class=c1></span>					<span class=c1>// array of strings; we will concatenate after
</span><span class=c1></span>					<span class=nx>intermediate</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kd>interface</span><span class=p>{},</span> <span class=nx>as</span><span class=p>.</span><span class=nx>ArrayLength</span><span class=p>)</span>
					<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>intermediate</span> <span class=p>{</span>
						<span class=nx>intermediate</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nb>new</span><span class=p>(</span><span class=kt>string</span><span class=p>)</span>
					<span class=p>}</span>
					<span class=nx>array</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>intermediate</span>
				<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
					<span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;argument %d should be array, slice or string&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
				<span class=p>}</span>
			<span class=p>}</span>

			<span class=k>if</span> <span class=nx>as</span><span class=p>.</span><span class=nx>ArrayLength</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
				<span class=k>if</span> <span class=nb>int</span><span class=p>(</span><span class=nx>as</span><span class=p>.</span><span class=nx>ArrayLength</span><span class=p>)</span> <span class=o>!=</span> <span class=nb>len</span><span class=p>(</span><span class=o>*</span><span class=nx>array</span><span class=p>)</span> <span class=p>{</span>
					<span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;argument %d should be array or slice of %d elements&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>as</span><span class=p>.</span><span class=nx>ArrayLength</span><span class=p>)</span>
				<span class=p>}</span>

				<span class=k>for</span> <span class=nx>n</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>n</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=o>*</span><span class=nx>array</span><span class=p>);</span> <span class=nx>n</span><span class=o>++</span> <span class=p>{</span>
					<span class=nx>err</span> <span class=o>:=</span> <span class=nf>getPrimitive</span><span class=p>((</span><span class=o>*</span><span class=nx>array</span><span class=p>)[</span><span class=nx>n</span><span class=p>],</span> <span class=nx>as</span><span class=p>)</span>
					<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
						<span class=k>return</span> <span class=nx>err</span>
					<span class=p>}</span>
				<span class=p>}</span>
			<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
				<span class=kd>var</span> <span class=nx>o</span> <span class=kt>int64</span>
				<span class=kd>var</span> <span class=nx>length</span> <span class=kt>int64</span>

				<span class=nx>l</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>offType</span><span class=p>.</span><span class=nf>unpack</span><span class=p>(</span><span class=nx>data</span><span class=p>,</span> <span class=nx>offset</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>o</span><span class=p>)</span>
				<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
					<span class=k>return</span> <span class=nx>err</span>
				<span class=p>}</span>

				<span class=nx>offset</span> <span class=o>+=</span> <span class=nx>l</span>
				<span class=nx>s</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>offType</span><span class=p>.</span><span class=nf>unpack</span><span class=p>(</span><span class=nx>data</span><span class=p>,</span> <span class=nb>int</span><span class=p>(</span><span class=nx>o</span><span class=p>),</span> <span class=o>&amp;</span><span class=nx>length</span><span class=p>)</span>
				<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
					<span class=k>return</span> <span class=nx>err</span>
				<span class=p>}</span>
				<span class=nx>o</span> <span class=o>+=</span> <span class=nb>int64</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>

				<span class=nx>intermediate</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kd>interface</span><span class=p>{},</span> <span class=nx>length</span><span class=p>)</span>

				<span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>arg</span><span class=p>.(</span><span class=o>*</span><span class=kt>string</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
					<span class=c1>// We have been asked to return the value as a string; make intermediate
</span><span class=c1></span>					<span class=c1>// array of strings; we will concatenate after
</span><span class=c1></span>					<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>intermediate</span> <span class=p>{</span>
						<span class=nx>intermediate</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nb>new</span><span class=p>(</span><span class=kt>string</span><span class=p>)</span>
					<span class=p>}</span>
				<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
					<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>intermediate</span> <span class=p>{</span>
						<span class=nx>intermediate</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>as</span><span class=p>.</span><span class=nx>EVM</span><span class=p>.</span><span class=nf>getGoType</span><span class=p>()</span>
					<span class=p>}</span>
				<span class=p>}</span>

				<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>int</span><span class=p>(</span><span class=nx>length</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
					<span class=nx>l</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>as</span><span class=p>.</span><span class=nx>EVM</span><span class=p>.</span><span class=nf>unpack</span><span class=p>(</span><span class=nx>data</span><span class=p>,</span> <span class=nb>int</span><span class=p>(</span><span class=nx>o</span><span class=p>),</span> <span class=nx>intermediate</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span>
					<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
						<span class=k>return</span> <span class=nx>err</span>
					<span class=p>}</span>
					<span class=nx>o</span> <span class=o>+=</span> <span class=nb>int64</span><span class=p>(</span><span class=nx>l</span><span class=p>)</span>
				<span class=p>}</span>

				<span class=nx>array</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>intermediate</span>
			<span class=p>}</span>

			<span class=c1>// If we were supposed to return a string, convert it back
</span><span class=c1></span>			<span class=k>if</span> <span class=nx>ret</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>arg</span><span class=p>.(</span><span class=o>*</span><span class=kt>string</span><span class=p>);</span> <span class=nx>ok</span> <span class=p>{</span>
				<span class=nx>s</span> <span class=o>:=</span> <span class=s>&#34;[&#34;</span>
				<span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>e</span> <span class=o>:=</span> <span class=k>range</span> <span class=o>*</span><span class=nx>array</span> <span class=p>{</span>
					<span class=k>if</span> <span class=nx>i</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
						<span class=nx>s</span> <span class=o>+=</span> <span class=s>&#34;,&#34;</span>
					<span class=p>}</span>
					<span class=nx>s</span> <span class=o>+=</span> <span class=o>*</span><span class=p>(</span><span class=nx>e</span><span class=p>.(</span><span class=o>*</span><span class=kt>string</span><span class=p>))</span>
				<span class=p>}</span>
				<span class=nx>s</span> <span class=o>+=</span> <span class=s>&#34;]&#34;</span>
				<span class=o>*</span><span class=nx>ret</span> <span class=p>=</span> <span class=nx>s</span>
			<span class=p>}</span>
		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
			<span class=nx>err</span> <span class=o>:=</span> <span class=nf>getPrimitive</span><span class=p>(</span><span class=nx>arg</span><span class=p>,</span> <span class=nx>as</span><span class=p>)</span>
			<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
				<span class=k>return</span> <span class=nx>err</span>
			<span class=p>}</span>
		<span class=p>}</span>
	<span class=p>}</span>

	<span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>unpack函数中定义了变量getPrimitive为一个函数 <code>func(e interface{}, a Argument) error</code> 调用Dynamic来判断是直接解码还是先获取偏移量值再解码，结果会保存在e实际传入的类型中</p><p>主循环中每次获取argSpec与args中的对应值，判断是否是array或者slice，如果是array类型，即<a href=#event_specgo rel>Argument</a>中的ArrayLength值大于0，则直接循环调用getPrimitive解码，如果是slice，需要先从data中获取slice的起始位置和长度，然后循环调用getPrimitive解码，如果是string类型则以逗号隔开，其余类型直接调用getPrimitive解码</p><h5 id=primitivesgo>primitives.go</h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// EVM Solidity calls and return values are packed into
</span><span class=c1>// pieces of 32 bytes, including a bool (wasting 255 out of 256 bits)
</span><span class=c1></span><span class=kd>const</span> <span class=nx>ElementSize</span> <span class=p>=</span> <span class=mi>32</span>

<span class=kd>type</span> <span class=nx>EVMType</span> <span class=kd>interface</span> <span class=p>{</span>
	<span class=nf>GetSignature</span><span class=p>()</span> <span class=kt>string</span>
	<span class=nf>getGoType</span><span class=p>()</span> <span class=kd>interface</span><span class=p>{}</span>
	<span class=nf>pack</span><span class=p>(</span><span class=nx>v</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
	<span class=nf>unpack</span><span class=p>(</span><span class=nx>data</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>offset</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>v</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
	<span class=nf>Dynamic</span><span class=p>()</span> <span class=kt>bool</span>
	<span class=nf>ImplicitCast</span><span class=p>(</span><span class=nx>o</span> <span class=nx>EVMType</span><span class=p>)</span> <span class=kt>bool</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>EVM Solidity合约调用以及返回值需要编码为32字节长的片段，EVMType中的pack和unpack方法即为每种类型具体的编码与解码方法</p><p>这里定义了EVMBool、EVMUint、EVMInt、EVMAddress、EVMBytes、EVMString、EVMFixed七种类型，他们均实现了EVMType接口，除了EVMFixed类型，其余类型均实现了pack/unpack方法</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>EVMBool</span> <span class=kd>struct</span> <span class=p>{</span>
<span class=p>}</span>
<span class=kd>type</span> <span class=nx>EVMUint</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>M</span> <span class=kt>uint64</span>
<span class=p>}</span>
<span class=kd>type</span> <span class=nx>EVMInt</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>M</span> <span class=kt>uint64</span>
<span class=p>}</span>
<span class=kd>type</span> <span class=nx>EVMAddress</span> <span class=kd>struct</span> <span class=p>{</span>
<span class=p>}</span>
<span class=kd>type</span> <span class=nx>EVMBytes</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>M</span> <span class=kt>uint64</span>
<span class=p>}</span>
<span class=kd>type</span> <span class=nx>EVMString</span> <span class=kd>struct</span> <span class=p>{</span>
<span class=p>}</span>
<span class=kd>type</span> <span class=nx>EVMFixed</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>N</span><span class=p>,</span> <span class=nx>M</span>   <span class=kt>uint64</span>
	<span class=nx>signed</span> <span class=kt>bool</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>其中EVMInt、EVMUint、EVMBytes中包含了一个uint64类型的字段M，它用来指示所存储的实际的类型是多少位长的，例如big.Int为256位，int64类型就是64位</p><p>EVMType的这些实现类型仅用来表示类型，它们<strong>不存储具体的值</strong></p><p>GetSignature方法会返回一个代表其类型的字符串</p><p>GetGoType方法会返回每种类型在go语言中对应的类型的实例</p><p>ImplicitCast方法表示其参数o是否可以转换为当前类型</p><p>pack方法的参数为一个空接口，调用pack方法时，它会通过反射获取到传入的实参的实际类型，然后根据具体类型进行编码并返回一个32字节长度的字符切片，对于无法编码的类型会报错</p><p>unpack方法接收三个参数，data存储要解码的数据，offset代表当前需要解码的数据在data中的偏移量，v是一个空接口，unpack会根据传入的v的实际类型判断是否可以解码为该类型，如果可以，将解码后的值存入v中，否则报错</p><h4 id=codego>code.go</h4><p><code>code.go</code> 对编译好的合约代码进行了一层封装，对代码中的指令和数据进行了标识</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>Code</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>Bytecode</span>     <span class=nx>acm</span><span class=p>.</span><span class=nx>Bytecode</span>
	<span class=nx>OpcodeBitset</span> <span class=nx>bitset</span><span class=p>.</span><span class=nx>Bitset</span>
<span class=p>}</span>

<span class=c1>// Build a Code object that includes analysis of which symbols are opcodes versus push data
</span><span class=c1></span><span class=kd>func</span> <span class=nf>NewCode</span><span class=p>(</span><span class=nx>code</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=o>*</span><span class=nx>Code</span> <span class=p>{</span>
	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>Code</span><span class=p>{</span>
		<span class=nx>Bytecode</span><span class=p>:</span>     <span class=nx>code</span><span class=p>,</span>
		<span class=nx>OpcodeBitset</span><span class=p>:</span> <span class=nf>opcodeBitset</span><span class=p>(</span><span class=nx>code</span><span class=p>),</span>
	<span class=p>}</span>
<span class=p>}</span>

<span class=c1>// If code[i] is an opcode (rather than PUSH data) then bitset.IsSet(i) will be true
</span><span class=c1></span><span class=kd>func</span> <span class=nf>opcodeBitset</span><span class=p>(</span><span class=nx>code</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=nx>bitset</span><span class=p>.</span><span class=nx>Bitset</span> <span class=p>{</span>
	<span class=nx>bs</span> <span class=o>:=</span> <span class=nx>bitset</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=nb>uint</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>code</span><span class=p>)))</span>
	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>code</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
		<span class=nx>bs</span><span class=p>.</span><span class=nf>Set</span><span class=p>(</span><span class=nb>uint</span><span class=p>(</span><span class=nx>i</span><span class=p>))</span>
		<span class=nx>symbol</span> <span class=o>:=</span> <span class=nx>asm</span><span class=p>.</span><span class=nf>OpCode</span><span class=p>(</span><span class=nx>code</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span>
		<span class=k>if</span> <span class=nx>symbol</span> <span class=o>&gt;=</span> <span class=nx>asm</span><span class=p>.</span><span class=nx>PUSH1</span> <span class=o>&amp;&amp;</span> <span class=nx>symbol</span> <span class=o>&lt;=</span> <span class=nx>asm</span><span class=p>.</span><span class=nx>PUSH32</span> <span class=p>{</span>
			<span class=nx>i</span> <span class=o>+=</span> <span class=nb>int</span><span class=p>(</span><span class=nx>symbol</span> <span class=o>-</span> <span class=nx>asm</span><span class=p>.</span><span class=nx>PUSH1</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
		<span class=p>}</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=nx>bs</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>opcodeBitset方法会将合约代码中的指令位设置为true</p><h4 id=evmcontractgo>evm/contract.go</h4><p><code>contract.go</code> 中包含了合约具体执行的过程</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>Contract</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=o>*</span><span class=nx>EVM</span>
	<span class=o>*</span><span class=nx>Code</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>Contract</span><span class=p>)</span> <span class=nf>Call</span><span class=p>(</span><span class=nx>state</span> <span class=nx>engine</span><span class=p>.</span><span class=nx>State</span><span class=p>,</span> <span class=nx>params</span> <span class=nx>engine</span><span class=p>.</span><span class=nx>CallParams</span><span class=p>)</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=k>return</span> <span class=nx>engine</span><span class=p>.</span><span class=nf>Call</span><span class=p>(</span><span class=nx>state</span><span class=p>,</span> <span class=nx>params</span><span class=p>,</span> <span class=nx>c</span><span class=p>.</span><span class=nx>execute</span><span class=p>)</span>
<span class=p>}</span>

<span class=c1>// Executes the EVM code passed in the appropriate context
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>Contract</span><span class=p>)</span> <span class=nf>execute</span><span class=p>(</span><span class=nx>st</span> <span class=nx>engine</span><span class=p>.</span><span class=nx>State</span><span class=p>,</span> <span class=nx>params</span> <span class=nx>engine</span><span class=p>.</span><span class=nx>CallParams</span><span class=p>)</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>c</span><span class=p>.</span><span class=nf>debugf</span><span class=p>(</span><span class=s>&#34;(%d) (%s) %s (code=%d) gas: %v (d) %X\n&#34;</span><span class=p>,</span>
		<span class=nx>st</span><span class=p>.</span><span class=nx>CallFrame</span><span class=p>.</span><span class=nf>CallStackDepth</span><span class=p>(),</span> <span class=nx>params</span><span class=p>.</span><span class=nx>Caller</span><span class=p>,</span> <span class=nx>params</span><span class=p>.</span><span class=nx>Callee</span><span class=p>,</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Length</span><span class=p>(),</span> <span class=o>*</span><span class=nx>params</span><span class=p>.</span><span class=nx>Gas</span><span class=p>,</span> <span class=nx>params</span><span class=p>.</span><span class=nx>Input</span><span class=p>)</span>

	<span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Length</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=kc>nil</span>
	<span class=p>}</span>

	<span class=k>if</span> <span class=nx>c</span><span class=p>.</span><span class=nx>options</span><span class=p>.</span><span class=nx>DumpTokens</span> <span class=p>{</span>
		<span class=nf>dumpTokens</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>options</span><span class=p>.</span><span class=nx>Nonce</span><span class=p>,</span> <span class=nx>params</span><span class=p>.</span><span class=nx>Caller</span><span class=p>,</span> <span class=nx>params</span><span class=p>.</span><span class=nx>Callee</span><span class=p>,</span> <span class=nx>c</span><span class=p>.</span><span class=nf>GetBytecode</span><span class=p>())</span>
	<span class=p>}</span>

	<span class=c1>// Program counter - the index into code that tracks current instruction
</span><span class=c1></span>	<span class=kd>var</span> <span class=nx>pc</span> <span class=kt>uint64</span>
	<span class=c1>// Return data from a call
</span><span class=c1></span>	<span class=kd>var</span> <span class=nx>returnData</span> <span class=p>[]</span><span class=kt>byte</span>

	<span class=c1>// Maybe serves 3 purposes: 1. provides &#39;capture first error semantics&#39;, 2. reduces clutter of error handling
</span><span class=c1></span>	<span class=c1>// particular for 1, 3. acts a shared error sink for stack, memory, and the main execute loop
</span><span class=c1></span>	<span class=nx>maybe</span> <span class=o>:=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>errors</span><span class=p>.</span><span class=nx>Maybe</span><span class=p>)</span>

	<span class=c1>// Provide stack and memory storage - passing in the callState as an error provider
</span><span class=c1></span>	<span class=nx>stack</span> <span class=o>:=</span> <span class=nf>NewStack</span><span class=p>(</span><span class=nx>maybe</span><span class=p>,</span> <span class=nx>c</span><span class=p>.</span><span class=nx>options</span><span class=p>.</span><span class=nx>DataStackInitialCapacity</span><span class=p>,</span> <span class=nx>c</span><span class=p>.</span><span class=nx>options</span><span class=p>.</span><span class=nx>DataStackMaxDepth</span><span class=p>,</span> <span class=nx>params</span><span class=p>.</span><span class=nx>Gas</span><span class=p>)</span>
	<span class=nx>memory</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>options</span><span class=p>.</span><span class=nf>MemoryProvider</span><span class=p>(</span><span class=nx>maybe</span><span class=p>)</span>

    <span class=c1>//主循环
</span><span class=c1></span>    <span class=k>for</span> <span class=p>{</span>

    <span class=p>}</span>

    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>maybe</span><span class=p>.</span><span class=nf>Error</span><span class=p>()</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Contract实现了<a href=#callablego rel>Callable.Call</a>接口，其内部调用了<a href=#callgo rel>engine.Call</a>函数，并将execute函数作为参数传入</p><p>execute是真正执行合约代码的函数，根据参数初始化pc、栈、内存，主循环为取指-执行循环，内部定义了每条指令的具体操作</p><h4 id=evmgo>evm.go</h4><p><code>evm.go</code> 中定义了EVM结构体类型以及EVM初始化函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>EVM</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>options</span>  <span class=nx>engine</span><span class=p>.</span><span class=nx>Options</span>
	<span class=nx>sequence</span> <span class=kt>uint64</span>
	<span class=c1>// Provide any foreign dispatchers to allow calls between VMs
</span><span class=c1></span>    <span class=c1>// Externals是一个实现了ExternalDispatcher接口的结构体类型
</span><span class=c1></span>	<span class=nx>engine</span><span class=p>.</span><span class=nx>Externals</span>
	<span class=nx>externalDispatcher</span> <span class=nx>engine</span><span class=p>.</span><span class=nx>Dispatcher</span>
	<span class=c1>// User dispatcher.CallableProvider to get access to other VMs
</span><span class=c1></span>	<span class=nx>logger</span> <span class=o>*</span><span class=nx>logging</span><span class=p>.</span><span class=nx>Logger</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>New</span><span class=p>(</span><span class=nx>options</span> <span class=nx>engine</span><span class=p>.</span><span class=nx>Options</span><span class=p>)</span> <span class=o>*</span><span class=nx>EVM</span> <span class=p>{</span>
	<span class=nx>options</span> <span class=p>=</span> <span class=nx>defaults</span><span class=p>.</span><span class=nf>CompleteOptions</span><span class=p>(</span><span class=nx>options</span><span class=p>)</span> <span class=c1>//如果Options中的MemoryProvider/Natives/Logger域为空，则将其设置为默认值
</span><span class=c1></span>    <span class=c1>//创建一个evm实例
</span><span class=c1></span>	<span class=nx>vm</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>EVM</span><span class=p>{</span>
		<span class=nx>options</span><span class=p>:</span> <span class=nx>options</span><span class=p>,</span>
	<span class=p>}</span>
    <span class=c1>//设置logger
</span><span class=c1></span>	<span class=nx>vm</span><span class=p>.</span><span class=nx>logger</span> <span class=p>=</span> <span class=nx>options</span><span class=p>.</span><span class=nx>Logger</span><span class=p>.</span><span class=nf>WithScope</span><span class=p>(</span><span class=s>&#34;NewVM&#34;</span><span class=p>).</span><span class=nf>With</span><span class=p>(</span><span class=s>&#34;evm_nonce&#34;</span><span class=p>,</span> <span class=nx>options</span><span class=p>.</span><span class=nx>Nonce</span><span class=p>)</span>
	<span class=nx>vm</span><span class=p>.</span><span class=nx>externalDispatcher</span> <span class=p>=</span> <span class=nx>engine</span><span class=p>.</span><span class=nx>Dispatchers</span><span class=p>{</span><span class=o>&amp;</span><span class=nx>vm</span><span class=p>.</span><span class=nx>Externals</span><span class=p>,</span> <span class=nx>options</span><span class=p>.</span><span class=nx>Natives</span><span class=p>,</span> <span class=nx>vm</span><span class=p>}</span>
	<span class=k>return</span> <span class=nx>vm</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>Default</span><span class=p>()</span> <span class=o>*</span><span class=nx>EVM</span> <span class=p>{</span>
	<span class=k>return</span> <span class=nf>New</span><span class=p>(</span><span class=nx>engine</span><span class=p>.</span><span class=nx>Options</span><span class=p>{})</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>可以看到新建一个evm实例需要传入一个<a href=#optionsgo rel>Options</a>结构体，它包含了evm实例所需的参数，如果Options中的MemoryProvider/Natives/Logger域为空，则CompleteOptions会将其设置为默认值</p><p>EVM结构体类型中包含一个engine.Externals匿名字段，Externals是一个实现了ExternalDispatcher接口的结构体类型，详见<a href=#dispatchergo rel>dispatcher.go</a>，evm可以使用其SetExternals方法设置外部dispatcher，例如wasm（实际上对于evm来说外部dispatcher好像只有wasm）</p><p>EVM结构体类型中还包括一个externalDispatcher字段，其类型为Dispatcher，可以看到在新建evm实例时该字段被设置为一个<a href=#dispatchergo rel>Dispatchers</a>类型，包含了上面提到的外部dispatcher，原生合约以及evm本身，因为EVM也实现了Dispatch方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>vm</span> <span class=o>*</span><span class=nx>EVM</span><span class=p>)</span> <span class=nf>Dispatch</span><span class=p>(</span><span class=nx>acc</span> <span class=o>*</span><span class=nx>acm</span><span class=p>.</span><span class=nx>Account</span><span class=p>)</span> <span class=nx>engine</span><span class=p>.</span><span class=nx>Callable</span> <span class=p>{</span>
	<span class=c1>// Let the EVM handle code-less (e.g. those created by a call) contracts (so only return nil if there is _other_ non-EVM code)
</span><span class=c1></span>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>acc</span><span class=p>.</span><span class=nx>EVMCode</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>acc</span><span class=p>.</span><span class=nf>Code</span><span class=p>())</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=nx>vm</span><span class=p>.</span><span class=nf>Contract</span><span class=p>(</span><span class=nx>acc</span><span class=p>.</span><span class=nx>EVMCode</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>vm</span> <span class=o>*</span><span class=nx>EVM</span><span class=p>)</span> <span class=nf>Contract</span><span class=p>(</span><span class=nx>code</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=o>*</span><span class=nx>Contract</span> <span class=p>{</span>
	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>Contract</span><span class=p>{</span>
		<span class=nx>EVM</span><span class=p>:</span>  <span class=nx>vm</span><span class=p>,</span>
		<span class=nx>Code</span><span class=p>:</span> <span class=nf>NewCode</span><span class=p>(</span><span class=nx>code</span><span class=p>),</span>
	<span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>EVM的Dispatch方法返回的是一个<a href=#evmcontractgo rel>Contract</a>类型，Dispatchers的Dispatch方法会遍历所有Dispatcher并返回一个有效的Callable</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// Initiate an EVM call against the provided state pushing events to eventSink. code should contain the EVM bytecode,
</span><span class=c1>// input the CallData (readable by CALLDATALOAD), value the amount of native token to transfer with the call
</span><span class=c1>// an quantity metering the number of computational steps available to the execution according to the gas schedule.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>vm</span> <span class=o>*</span><span class=nx>EVM</span><span class=p>)</span> <span class=nf>Execute</span><span class=p>(</span><span class=nx>st</span> <span class=nx>acmstate</span><span class=p>.</span><span class=nx>ReaderWriter</span><span class=p>,</span> <span class=nx>blockchain</span> <span class=nx>engine</span><span class=p>.</span><span class=nx>Blockchain</span><span class=p>,</span> <span class=nx>eventSink</span> <span class=nx>exec</span><span class=p>.</span><span class=nx>EventSink</span><span class=p>,</span>
	<span class=nx>params</span> <span class=nx>engine</span><span class=p>.</span><span class=nx>CallParams</span><span class=p>,</span> <span class=nx>code</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>

	<span class=c1>// Make it appear as if natives are stored in state
</span><span class=c1></span>	<span class=nx>st</span> <span class=p>=</span> <span class=nx>native</span><span class=p>.</span><span class=nf>NewState</span><span class=p>(</span><span class=nx>vm</span><span class=p>.</span><span class=nx>options</span><span class=p>.</span><span class=nx>Natives</span><span class=p>,</span> <span class=nx>st</span><span class=p>)</span>

	<span class=nx>state</span> <span class=o>:=</span> <span class=nx>engine</span><span class=p>.</span><span class=nx>State</span><span class=p>{</span>
		<span class=nx>CallFrame</span><span class=p>:</span>  <span class=nx>engine</span><span class=p>.</span><span class=nf>NewCallFrame</span><span class=p>(</span><span class=nx>st</span><span class=p>).</span><span class=nf>WithMaxCallStackDepth</span><span class=p>(</span><span class=nx>vm</span><span class=p>.</span><span class=nx>options</span><span class=p>.</span><span class=nx>CallStackMaxDepth</span><span class=p>),</span>
		<span class=nx>Blockchain</span><span class=p>:</span> <span class=nx>blockchain</span><span class=p>,</span>
		<span class=nx>EventSink</span><span class=p>:</span>  <span class=nx>eventSink</span><span class=p>,</span>
	<span class=p>}</span>

	<span class=nx>output</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>vm</span><span class=p>.</span><span class=nf>Contract</span><span class=p>(</span><span class=nx>code</span><span class=p>).</span><span class=nf>Call</span><span class=p>(</span><span class=nx>state</span><span class=p>,</span> <span class=nx>params</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=c1>// Only sync back when there was no exception
</span><span class=c1></span>		<span class=nx>err</span> <span class=p>=</span> <span class=nx>state</span><span class=p>.</span><span class=nx>CallFrame</span><span class=p>.</span><span class=nf>Sync</span><span class=p>()</span>
	<span class=p>}</span>
	<span class=c1>// Always return output - we may have a reverted exception for which the return is meaningful
</span><span class=c1></span>	<span class=k>return</span> <span class=nx>output</span><span class=p>,</span> <span class=nx>err</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Execute方法接收5个参数：ReaderWriter接口实现类型，用于读写账户状态；Blockchain接口实现类型，用于获取区块链相关信息；EventSink接口实现类型，用于记录event；CallParams结构体，包含了合约执行所需的参数；code，表示编译好的智能合约代码</p><p>Execute方法会调用native.NewState函数对ReaderWriter接口实现类型进行封装，使合约执行时先检查目标合约是否为原生合约</p><p>接下来会创建一个<a href=#enginestatego rel>State</a>结构体，作为参数传入<a href=#evmcontractgo rel>Contract</a>的Call方法来执行合约，并将结果保存至变量output中</p><p>当Call方法未出错时，调用Callframe的Sync方法将缓存中的账户状态变更写回，最后返回执行结果</p><h4 id=stackgo>stack.go</h4><p><code>stack.go</code> 中定义了evm中的栈以及相关栈操作</p><p>栈定义为 <code>Stack</code> 类型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// Not goroutine safe
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Stack</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>slice</span>       <span class=p>[]</span><span class=nx>Word256</span>
	<span class=nx>maxCapacity</span> <span class=kt>uint64</span>
	<span class=nx>ptr</span>         <span class=kt>int</span>

	<span class=nx>gas</span>     <span class=o>*</span><span class=nx>big</span><span class=p>.</span><span class=nx>Int</span>
	<span class=nx>errSink</span> <span class=nx>errors</span><span class=p>.</span><span class=nx>Sink</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h3 id=native>native</h3><p><code>native</code> 与原生合约有关，这里的原生合约(native contracts)的功能类似于以太坊evm中预编译好的合约，默认包括对于账户权限的操作和加密操作</p><h4 id=contractgo>contract.go</h4><p><code>contract.go</code> 中规定了原生合约声明函数的的规范，函数必须声明为以下形式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>unsetBase</span><span class=p>(</span><span class=nx>context</span> <span class=nx>Context</span><span class=p>,</span> <span class=nx>args</span> <span class=nx>unsetBaseArgs</span><span class=p>)</span> <span class=p>(</span><span class=nx>unsetBaseRets</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{}</span>
</code></pre></td></tr></table></div></div><p>必须有一个或两个参数以及两个返回值，第一个参数必须是 <code>Context</code> 类型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// Context is the first argument to any native function. This struct carries
</span><span class=c1>// all the context an native needs to access e.g. state in burrow.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Context</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>State</span> <span class=nx>engine</span><span class=p>.</span><span class=nx>State</span>
	<span class=nx>engine</span><span class=p>.</span><span class=nx>CallParams</span>
	<span class=c1>// TODO: this allows us to call back to EVM contracts if we wish - make use of it somewhere...
</span><span class=c1></span>	<span class=nx>externals</span> <span class=nx>engine</span><span class=p>.</span><span class=nx>Dispatcher</span>
	<span class=nx>Logger</span>    <span class=o>*</span><span class=nx>logging</span><span class=p>.</span><span class=nx>Logger</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>第二个参数以及第一个返回值必须是结构体类型，与solidity函数中的参数与返回值一一对应，第二个返回值必须是error类型</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// Contract is metadata for native contract. Acts as a call target
</span><span class=c1>// from the EVM. Can be used to generate bindings in a smart contract languages.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Contract</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=c1>// Comment describing purpose of native contract and reason for assembling
</span><span class=c1></span>	<span class=c1>// the particular functions
</span><span class=c1></span>	<span class=nx>Comment</span> <span class=kt>string</span>
	<span class=c1>// Name of the native contract
</span><span class=c1></span>	<span class=nx>Name</span>          <span class=kt>string</span>
	<span class=nx>functionsByID</span> <span class=kd>map</span><span class=p>[</span><span class=nx>abi</span><span class=p>.</span><span class=nx>FunctionID</span><span class=p>]</span><span class=o>*</span><span class=nx>Function</span>
	<span class=nx>functions</span>     <span class=p>[]</span><span class=o>*</span><span class=nx>Function</span>
	<span class=nx>address</span>       <span class=nx>crypto</span><span class=p>.</span><span class=nx>Address</span>
	<span class=nx>logger</span>        <span class=o>*</span><span class=nx>logging</span><span class=p>.</span><span class=nx>Logger</span>
<span class=p>}</span>

<span class=kd>var</span> <span class=nx>_</span> <span class=nx>engine</span><span class=p>.</span><span class=nx>Native</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>Contract</span><span class=p>{}</span>
</code></pre></td></tr></table></div></div><p>Contract结构体类型实现了<a href=#enginenativesgo rel>engine.Native</a>接口，包含一个<a href=#functiongo rel>Function</a>列表，实际执行均由Function进行，Contract对Function进行了一层包装</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// Dispatch is designed to be called from the EVM once a native contract
</span><span class=c1>// has been selected.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>Contract</span><span class=p>)</span> <span class=nf>Call</span><span class=p>(</span><span class=nx>state</span> <span class=nx>engine</span><span class=p>.</span><span class=nx>State</span><span class=p>,</span> <span class=nx>params</span> <span class=nx>engine</span><span class=p>.</span><span class=nx>CallParams</span><span class=p>)</span> <span class=p>(</span><span class=nx>output</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>params</span><span class=p>.</span><span class=nx>Input</span><span class=p>)</span> <span class=p>&lt;</span> <span class=nx>abi</span><span class=p>.</span><span class=nx>FunctionIDSize</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=nx>errors</span><span class=p>.</span><span class=nx>Codes</span><span class=p>.</span><span class=nx>NativeFunction</span><span class=p>,</span>
			<span class=s>&#34;Burrow Native dispatch requires a 4-byte function identifier but arguments are only %v bytes long&#34;</span><span class=p>,</span>
			<span class=nb>len</span><span class=p>(</span><span class=nx>params</span><span class=p>.</span><span class=nx>Input</span><span class=p>))</span>
	<span class=p>}</span>

	<span class=kd>var</span> <span class=nx>id</span> <span class=nx>abi</span><span class=p>.</span><span class=nx>FunctionID</span>
	<span class=nb>copy</span><span class=p>(</span><span class=nx>id</span><span class=p>[:],</span> <span class=nx>params</span><span class=p>.</span><span class=nx>Input</span><span class=p>)</span>
	<span class=nx>function</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>FunctionByID</span><span class=p>(</span><span class=nx>id</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
	<span class=p>}</span>

	<span class=nx>params</span><span class=p>.</span><span class=nx>Input</span> <span class=p>=</span> <span class=nx>params</span><span class=p>.</span><span class=nx>Input</span><span class=p>[</span><span class=nx>abi</span><span class=p>.</span><span class=nx>FunctionIDSize</span><span class=p>:]</span>

	<span class=k>return</span> <span class=nx>function</span><span class=p>.</span><span class=nf>Call</span><span class=p>(</span><span class=nx>state</span><span class=p>,</span> <span class=nx>params</span><span class=p>)</span>
<span class=p>}</span>

<span class=c1>// Get function by calling identifier FunctionSelector
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>Contract</span><span class=p>)</span> <span class=nf>FunctionByID</span><span class=p>(</span><span class=nx>id</span> <span class=nx>abi</span><span class=p>.</span><span class=nx>FunctionID</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>Function</span><span class=p>,</span> <span class=nx>errors</span><span class=p>.</span><span class=nx>CodedError</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>f</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nx>functionsByID</span><span class=p>[</span><span class=nx>id</span><span class=p>]</span>
	<span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span>
			<span class=nx>errors</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=nx>errors</span><span class=p>.</span><span class=nx>Codes</span><span class=p>.</span><span class=nx>NativeFunction</span><span class=p>,</span> <span class=s>&#34;unknown native function with ID %x&#34;</span><span class=p>,</span> <span class=nx>id</span><span class=p>)</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=nx>f</span><span class=p>,</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Contract类型实现了<a href=#callablego rel>Callable</a>接口，其Call函数内部根据param中的Input字段获取FunctionID并获取相应的Function，然后调用Function中的Call函数执行</p><h4 id=functiongo>function.go</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// Function is metadata for native functions. Act as call targets
</span><span class=c1>// for the EVM when collected into an Contract. Can be used to generate
</span><span class=c1>// bindings in a smart contract languages.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Function</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=c1>// Comment describing function&#39;s purpose, parameters, and return value
</span><span class=c1></span>	<span class=nx>Comment</span> <span class=kt>string</span>
	<span class=c1>// Permissions required to call function
</span><span class=c1></span>	<span class=nx>PermFlag</span> <span class=nx>permission</span><span class=p>.</span><span class=nx>PermFlag</span>
	<span class=c1>// Whether this function writes to state
</span><span class=c1></span>	<span class=nx>Pure</span> <span class=kt>bool</span>
	<span class=c1>// Native function to which calls will be dispatched when a containing
</span><span class=c1></span>	<span class=nx>F</span> <span class=kd>interface</span><span class=p>{}</span>
	<span class=c1>// Following fields are for only for memoization
</span><span class=c1></span>	<span class=c1>// The name of the contract to which this function belongs (if any)
</span><span class=c1></span>	<span class=nx>contractName</span> <span class=kt>string</span>
	<span class=c1>// Function name (used to form signature)
</span><span class=c1></span>	<span class=nx>name</span> <span class=kt>string</span>
	<span class=c1>// The abi
</span><span class=c1></span>	<span class=nx>abi</span> <span class=o>*</span><span class=nx>abi</span><span class=p>.</span><span class=nx>FunctionSpec</span>
	<span class=c1>// Address of containing contract
</span><span class=c1></span>	<span class=nx>address</span>   <span class=nx>crypto</span><span class=p>.</span><span class=nx>Address</span>
	<span class=nx>externals</span> <span class=nx>engine</span><span class=p>.</span><span class=nx>Dispatcher</span>
	<span class=nx>logger</span>    <span class=o>*</span><span class=nx>logging</span><span class=p>.</span><span class=nx>Logger</span>
<span class=p>}</span>

<span class=kd>var</span> <span class=nx>_</span> <span class=nx>engine</span><span class=p>.</span><span class=nx>Native</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>Function</span><span class=p>{}</span>
</code></pre></td></tr></table></div></div><p>Function类型也实现了<a href=#enginenativesgo rel>engine.Native</a>接口，其中的F字段即为native function，也就是由go语言实现的函数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// Created a new function mounted directly at address (i.e. no Solidity contract or function selection)
</span><span class=c1></span><span class=kd>func</span> <span class=nf>NewFunction</span><span class=p>(</span><span class=nx>comment</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>address</span> <span class=nx>crypto</span><span class=p>.</span><span class=nx>Address</span><span class=p>,</span> <span class=nx>permFlag</span> <span class=nx>permission</span><span class=p>.</span><span class=nx>PermFlag</span><span class=p>,</span> <span class=nx>f</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>(</span><span class=o>*</span><span class=nx>Function</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>function</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Function</span><span class=p>{</span>
		<span class=nx>Comment</span><span class=p>:</span>  <span class=nx>comment</span><span class=p>,</span>
		<span class=nx>PermFlag</span><span class=p>:</span> <span class=nx>permFlag</span><span class=p>,</span>
		<span class=nx>F</span><span class=p>:</span>        <span class=nx>f</span><span class=p>,</span>
	<span class=p>}</span>
	<span class=nx>err</span> <span class=o>:=</span> <span class=nx>function</span><span class=p>.</span><span class=nf>init</span><span class=p>(</span><span class=nx>address</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=nx>function</span><span class=p>,</span> <span class=kc>nil</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>Function</span><span class=p>)</span> <span class=nf>init</span><span class=p>(</span><span class=nx>address</span> <span class=nx>crypto</span><span class=p>.</span><span class=nx>Address</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
	<span class=c1>// Get name of function
</span><span class=c1></span>	<span class=nx>t</span> <span class=o>:=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nf>TypeOf</span><span class=p>(</span><span class=nx>f</span><span class=p>.</span><span class=nx>F</span><span class=p>)</span>
	<span class=nx>v</span> <span class=o>:=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nf>ValueOf</span><span class=p>(</span><span class=nx>f</span><span class=p>.</span><span class=nx>F</span><span class=p>)</span>
	<span class=c1>// v.String() for functions returns the empty string
</span><span class=c1></span>	<span class=nx>fullyQualifiedName</span> <span class=o>:=</span> <span class=nx>runtime</span><span class=p>.</span><span class=nf>FuncForPC</span><span class=p>(</span><span class=nx>v</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>()).</span><span class=nf>Name</span><span class=p>()</span>
	<span class=nx>a</span> <span class=o>:=</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>Split</span><span class=p>(</span><span class=nx>fullyQualifiedName</span><span class=p>,</span> <span class=s>&#34;.&#34;</span><span class=p>)</span>
	<span class=nx>f</span><span class=p>.</span><span class=nx>name</span> <span class=p>=</span> <span class=nx>a</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>

	<span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nf>NumIn</span><span class=p>()</span> <span class=o>!=</span> <span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=nx>t</span><span class=p>.</span><span class=nf>NumIn</span><span class=p>()</span> <span class=o>!=</span> <span class=mi>2</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;native function %s must have a one or two arguments&#34;</span><span class=p>,</span> <span class=nx>fullyQualifiedName</span><span class=p>)</span>
	<span class=p>}</span>

	<span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nf>NumOut</span><span class=p>()</span> <span class=o>!=</span> <span class=mi>2</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;native function %s must return a single struct and an error&#34;</span><span class=p>,</span> <span class=nx>fullyQualifiedName</span><span class=p>)</span>
	<span class=p>}</span>

	<span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nf>In</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>!=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nf>TypeOf</span><span class=p>(</span><span class=nx>Context</span><span class=p>{})</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;first agument of %s must be struct Context&#34;</span><span class=p>,</span> <span class=nx>fullyQualifiedName</span><span class=p>)</span>
	<span class=p>}</span>

	<span class=k>if</span> <span class=nx>t</span><span class=p>.</span><span class=nf>NumIn</span><span class=p>()</span> <span class=o>==</span> <span class=mi>2</span> <span class=p>{</span>
		<span class=c1>//In()方法用于返回第二个参数的类型，Out()方法用于返回第一个返回值的类型
</span><span class=c1></span>		<span class=nx>f</span><span class=p>.</span><span class=nx>abi</span> <span class=p>=</span> <span class=nx>abi</span><span class=p>.</span><span class=nf>SpecFromStructReflect</span><span class=p>(</span><span class=nx>f</span><span class=p>.</span><span class=nx>name</span><span class=p>,</span> <span class=nx>t</span><span class=p>.</span><span class=nf>In</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span> <span class=nx>t</span><span class=p>.</span><span class=nf>Out</span><span class=p>(</span><span class=mi>0</span><span class=p>))</span>
	<span class=p>}</span>
	<span class=nx>f</span><span class=p>.</span><span class=nx>address</span> <span class=p>=</span> <span class=nx>address</span>
	<span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>NewFunction函数接受四个参数来创建一个新的Function，其中address表示该函数将安装在哪个地址上，其余三个参数用于创建一个新的Function，然后调用init初始化其他字段</p><p>init方法中使用反射获取到储存在接口变量F内部的方法的类型和值，然后通过函数指针获取到函数名，并检查参数以及返回值的数量和类型是否正确，如果方法的参数有两个，则调用abi中的<a href=#abigo rel>SpecFromStructReflect</a>方法获取一个<a href=#function_specgo rel>FunctionSpec</a>类型作为函数的abi字段值，最后设置函数的地址</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>Function</span><span class=p>)</span> <span class=nf>Call</span><span class=p>(</span><span class=nx>state</span> <span class=nx>engine</span><span class=p>.</span><span class=nx>State</span><span class=p>,</span> <span class=nx>params</span> <span class=nx>engine</span><span class=p>.</span><span class=nx>CallParams</span><span class=p>)</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=k>return</span> <span class=nx>engine</span><span class=p>.</span><span class=nf>Call</span><span class=p>(</span><span class=nx>state</span><span class=p>,</span> <span class=nx>params</span><span class=p>,</span> <span class=nx>f</span><span class=p>.</span><span class=nx>execute</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>Function</span><span class=p>)</span> <span class=nf>execute</span><span class=p>(</span><span class=nx>state</span> <span class=nx>engine</span><span class=p>.</span><span class=nx>State</span><span class=p>,</span> <span class=nx>params</span> <span class=nx>engine</span><span class=p>.</span><span class=nx>CallParams</span><span class=p>)</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=c1>// check if we have permission to call this function
</span><span class=c1></span>	<span class=nx>hasPermission</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>engine</span><span class=p>.</span><span class=nf>HasPermission</span><span class=p>(</span><span class=nx>state</span><span class=p>.</span><span class=nx>CallFrame</span><span class=p>,</span> <span class=nx>params</span><span class=p>.</span><span class=nx>Caller</span><span class=p>,</span> <span class=nx>f</span><span class=p>.</span><span class=nx>PermFlag</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
	<span class=p>}</span>
	<span class=k>if</span> <span class=p>!</span><span class=nx>hasPermission</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>errors</span><span class=p>.</span><span class=nx>LacksNativePermission</span><span class=p>{</span><span class=nx>Address</span><span class=p>:</span> <span class=nx>params</span><span class=p>.</span><span class=nx>Caller</span><span class=p>,</span> <span class=nx>NativeName</span><span class=p>:</span> <span class=nx>f</span><span class=p>.</span><span class=nx>name</span><span class=p>}</span>
	<span class=p>}</span>

	<span class=nx>ctx</span> <span class=o>:=</span> <span class=nx>Context</span><span class=p>{</span>
		<span class=nx>State</span><span class=p>:</span>      <span class=nx>state</span><span class=p>,</span>
		<span class=nx>CallParams</span><span class=p>:</span> <span class=nx>params</span><span class=p>,</span>
		<span class=nx>externals</span><span class=p>:</span>  <span class=nx>f</span><span class=p>.</span><span class=nx>externals</span><span class=p>,</span>
		<span class=nx>Logger</span><span class=p>:</span>     <span class=nx>f</span><span class=p>.</span><span class=nx>logger</span><span class=p>,</span>
	<span class=p>}</span>
	<span class=nx>fnv</span> <span class=o>:=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nf>ValueOf</span><span class=p>(</span><span class=nx>f</span><span class=p>.</span><span class=nx>F</span><span class=p>)</span>
	<span class=nx>fnt</span> <span class=o>:=</span> <span class=nx>fnv</span><span class=p>.</span><span class=nf>Type</span><span class=p>()</span>

	<span class=nx>args</span> <span class=o>:=</span> <span class=p>[]</span><span class=nx>reflect</span><span class=p>.</span><span class=nx>Value</span><span class=p>{</span><span class=nx>reflect</span><span class=p>.</span><span class=nf>ValueOf</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)}</span>

	<span class=k>if</span> <span class=nx>f</span><span class=p>.</span><span class=nx>abi</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=c1>//New方法接收一个reflect.Type类型作为参数，返回一个reflect.Value类型，代表一个指向该类型零值的指针
</span><span class=c1></span>		<span class=nx>arguments</span> <span class=o>:=</span> <span class=nx>reflect</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=nx>fnt</span><span class=p>.</span><span class=nf>In</span><span class=p>(</span><span class=mi>1</span><span class=p>))</span>
		<span class=nx>err</span> <span class=p>=</span> <span class=nx>abi</span><span class=p>.</span><span class=nf>Unpack</span><span class=p>(</span><span class=nx>f</span><span class=p>.</span><span class=nx>abi</span><span class=p>.</span><span class=nx>Inputs</span><span class=p>,</span> <span class=nx>params</span><span class=p>.</span><span class=nx>Input</span><span class=p>,</span> <span class=nx>arguments</span><span class=p>.</span><span class=nf>Interface</span><span class=p>())</span>
		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
		<span class=p>}</span>
		<span class=nx>args</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>args</span><span class=p>,</span> <span class=nx>arguments</span><span class=p>.</span><span class=nf>Elem</span><span class=p>())</span>
	<span class=p>}</span>

	<span class=nx>rets</span> <span class=o>:=</span> <span class=nx>fnv</span><span class=p>.</span><span class=nf>Call</span><span class=p>(</span><span class=nx>args</span><span class=p>)</span>
	<span class=k>if</span> <span class=p>!</span><span class=nx>rets</span><span class=p>[</span><span class=mi>1</span><span class=p>].</span><span class=nf>IsNil</span><span class=p>()</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>rets</span><span class=p>[</span><span class=mi>1</span><span class=p>].</span><span class=nf>Interface</span><span class=p>().(</span><span class=kt>error</span><span class=p>)</span>
	<span class=p>}</span>

	<span class=nx>ret</span> <span class=o>:=</span> <span class=nx>rets</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=nf>Interface</span><span class=p>()</span>
	<span class=k>if</span> <span class=nx>f</span><span class=p>.</span><span class=nx>abi</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>abi</span><span class=p>.</span><span class=nf>Pack</span><span class=p>(</span><span class=nx>f</span><span class=p>.</span><span class=nx>abi</span><span class=p>.</span><span class=nx>Outputs</span><span class=p>,</span> <span class=nx>ret</span><span class=p>)</span>
	<span class=p>}</span>

	<span class=nx>output</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>ret</span><span class=p>.([]</span><span class=kt>byte</span><span class=p>)</span>
	<span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;function has no associated ABI but returns %T instead of []byte&#34;</span><span class=p>,</span> <span class=nx>ret</span><span class=p>)</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=nx>output</span><span class=p>,</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>Function也实现了<a href=#callablego rel>Callable</a>接口，其实现方式与<a href=#evmcontractgo rel>evm/contract</a>类似，将具体的执行过程定义在了execute函数中</p><p>execute函数首先进行权限检查，然后根据传入的参数和Function本身的字段构造一个Context作为原生go函数执行的第一个参数，并通过反射获取F字段，也就是实际上要执行的go函数的reflect.Type和reflect.Value类型</p><p>如果Function的abi字段非空，则说明该函数会接收两个参数，需要从params.Input字段中获取第二个参数，而该参数是经过编码以适用于evm执行的字节序列，因此需要调用<a href=#packinggo rel>abi.Unpack</a>进行解码恢复成go函数可以使用的字节序列</p><p>将Context和参数转为reflect.Value类型，并调用reflect.Value.Call函数进行执行</p><h4 id=nativego>native.go</h4><p><code>native.go</code> 中定义了获取默认原生合约的方法</p><h4 id=nativenativesgo>native/natives.go</h4><p><code>natives.go</code> 中定义了Natives结构体类型，用于根据地址或者名称来获取对应的原生合约/原生函数，实现了<a href=#enginenativesgo rel>Natives</a>接口</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>Natives</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>callableByAddress</span> <span class=kd>map</span><span class=p>[</span><span class=nx>crypto</span><span class=p>.</span><span class=nx>Address</span><span class=p>]</span><span class=nx>engine</span><span class=p>.</span><span class=nx>Native</span>
	<span class=nx>callableByName</span>    <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>engine</span><span class=p>.</span><span class=nx>Native</span>
	<span class=nx>logger</span>            <span class=o>*</span><span class=nx>logging</span><span class=p>.</span><span class=nx>Logger</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h4 id=permissionsgo>permissions.go</h4><p><code>permissions.go</code> 中定义了与权限操作相关的函数，并根据这些函数创建对应的<a href=#functiongo rel>Native Function</a>，然后组织为一个名为Permissions的<a href=#contractgo rel>Native Contract</a></p><h4 id=precompilesgo>precompiles.go</h4><p><code>precompiles.go</code> 中定义了与加密操作相关的函数，并根据这些函数创建了对应的<a href=#functiongo rel>Native Function</a></p><h4 id=nativestatego>native/state.go</h4><p><code>state.go</code> 中定义了一个State结构体类型，包含一个<a href=#enginenativesgo rel>Natives</a>实现类型和<a href=#acmstate rel>ReaderWriter</a>实现类型，对ReaderWriter接口进行了一层封装，使evm在执行时先检查传入的地址是否是原生合约的地址</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>State</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>natives</span> <span class=nx>engine</span><span class=p>.</span><span class=nx>Natives</span>
	<span class=nx>backend</span> <span class=nx>acmstate</span><span class=p>.</span><span class=nx>ReaderWriter</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h2 id=参考链接>参考链接</h2><p><a href=https://juejin.cn/post/6844903559335526407 target=_blank rel="noopener noreffer">Golang的反射reflect深入理解和示例</a></p><p><a href=https://blog.go-zh.org/laws-of-reflection target=_blank rel="noopener noreffer">反射三法则</a></p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2021-05-23</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/burrow-evm/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/evm/>evm</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/slices_in_go/ class=prev rel=prev title="slice in Go"><i class="fas fa-angle-left fa-fw"></i>slice in Go</a>
<a href=/interface_in_go/ class=next rel=next title="interface in go">interface in go<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://zhangxu1814.github.io target=_blank>zhangxu1814</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/katex/copy-tex.min.css><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/algoliasearch/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/auto-render.min.js></script><script type=text/javascript src=/lib/katex/copy-tex.min.js></script><script type=text/javascript src=/lib/katex/mhchem.min.js></script><script type=text/javascript src=/lib/cookieconsent/cookieconsent.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验."},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"",algoliaIndex:"",algoliaSearchKey:"",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>