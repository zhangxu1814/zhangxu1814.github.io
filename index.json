[{"categories":["Go"],"content":"go语言的接口表示一个确定的方法集，并且是隐式实现的，也就是说无需像java那样显式的说明该类实现了哪个接口，只要某个非接口类型的具体值实现了某个接口里的全部方法，就可以说该值实现了某个接口类型，该接口类型的变量就能存储它。 一个典型的例子是io.Reader和io.Writer，即io包中的Reader和Writer类型： // Reader is the interface that wraps the basic Read method. type Reader interface { Read(p []byte) (n int, err error) } // Writer is the interface that wraps the basic Write method. type Writer interface { Write(p []byte) (n int, err error) } 任何正确实现了Read/Write方法（指方法的参数和返回值要对应）的类型，同时也就实现了io.Reader/io.Writer接口。如果某个值的类型实现了Read方法，io.Reader类型的变量就能保存它： var r io.Reader r = os.Stdin r = bufio.NewReader(r) r = new(bytes.Buffer) // and so on 无论r保存了什么具体的值，r的类型总是io.Reader：Go是静态类型的，而r的静态类型就是io.Reader ","date":"2021-06-17","objectID":"/interface_in_go/:0:0","tags":["Go","interface"],"title":"interface in go","uri":"/interface_in_go/"},{"categories":["Go"],"content":"接口的使用 首先定义接口类型： type ReadCloser interface { Read(b []byte) (n int, err os.Error) Close() } 然后定义一个函数，需要传入一个ReadCloser类型作为参数： func ReadAndClose(r ReadCloser, buf []byte) (n int, err os.Error) { for len(buf) \u003e 0 \u0026\u0026 err == nil { var nr int nr, err = r.Read(buf) n += nr buf = buf[nr:] } r.Close() return } 该函数会循环读取buf中的数据然后调用close 调用该函数的代码需要传入一个值，该值的类型必须正确的实现Read和Close方法。不同于Python，如果你传入了一个错误类型的值，会在编译时报错而不是运行时 接口并不是只能静态检查，你也可以动态地检查特定的接口值是否有确定的方法： type Stringer interface { String() string } func ToString(any interface{}) string { if v, ok := any.(Stringer); ok { return v.String() } switch v := any.(type) { case int: return strconv.Itoa(v) case float: return strconv.Ftoa(v, 'g', -1) } return \"???\" } ToString方法传入的参数any是interface{}类型，也就是空接口类型，它表示空方法集，因为任何值都有零个或多个方法，因此任何值都满足空接口，也就是说空接口可以包括任何值。if语句表示将any转为Stringer类型的值是否可行。如果可行，调用String()方法，否则执行switch语句判断是否是其他类型。这个过程类似于fmt包的执行过程 为64位的integer类型实现一个Stringer()方法： type Binary uint64 func (i Binary) String() string { return strconv.Uitob64(i.Get(), 2) } func (i Binary) Get() uint64 { return uint64(i) } 这样一个Binary类型的值就可以作为参数传入ToString方法中，然后就可以调用String方法将其值格式化，即使Binary并没有显式的声明它实现了Stringer接口，甚至写Binary的人不知道Stringer接口的存在 上述例子表明即使在编译时完成了隐式转换的检查，显式的接口间的转换会在运行时检查方法集，Effective Go中有更详细的解释 ","date":"2021-06-17","objectID":"/interface_in_go/:1:0","tags":["Go","interface"],"title":"interface in go","uri":"/interface_in_go/"},{"categories":["Go"],"content":"接口值 一个Binary类型的值是一个64位的Integer，占两个字长。这里声明一个变量b为一个值为200的Binary类型，如下图所示： 一个接口值代表了了一对内容：一个指针指向存储在该接口中的具体的底层类型描述符，另一个指针指向该具体类型的具体的值。这里声明一个变量s，s是一个Stringer接口类型，其实际存储的是上面声明的变量b： 上图中的指针图标是灰色的，用以强调它们是隐式的，不直接暴露给go程序 接口值中的第一个字段指向接口表，也就是上图中的itable，itable中包含了存储的底层类型的元数据和函数指针的列表。这里itable对应的是具体类型，而不是接口类型。在这个例子里面，Stringer的itable保存的是Binary类型，以及满足Stringer接口的方法Sting()，Binary的另一个方法Get()并没有被包含在itable中 接口值中的第二个字段指向实际的值，在这个例子里面是变量b的一个副本。赋值语句 var s Stringer = b 创造了一个b的副本，而不是直接指向b，同样的，var c uint64 = b 也创建了一个b的副本，如果b的值变化了，s和c会维持原来的值，而不会变为新的值。接口中保存的值可能是任意大小，但是接口实际上只是保存相应的指针，因此上述的赋值语句会在堆上分配一块内存来记录实际的值 在给接口赋值时，编译器会根据itable中的信息检查类型是否正确，如果类型匹配，则会复制一份副本存储。调用接口函数时，编译器会根据itable中的函数指针列表调用对应的函数，同时传入指向实际值的指针。通常接口在调用函数时不知道传入的这个指针字段的意义是什么，也不知道这个指针指向什么值，只是itable中的函数指针需要该指针字段作为参数。因此，在这个例子里面，函数指针是 (*Binary).String 而不是 Binary.String 。 ","date":"2021-06-17","objectID":"/interface_in_go/:2:0","tags":["Go","interface"],"title":"interface in go","uri":"/interface_in_go/"},{"categories":["Go"],"content":"生成Itable 现在我们知道itables长什么样了，但是它是怎么生成的呢？编译器为每个具体类型，例如Binary，int，func(map[int]string)等创建类型描述符，包含了元数据，方法列表等等信息，然后为每个结构体常见类似的类型描述符，接口在运行时根据自己的方法表去查找具体类型的类型描述符中对应的方法列表来生成itable 在我们的例子中，Stringer拥有1个方法，Binary有两个方法。假设接口类型有ni个方法，具体类型有nt个方法，寻找每个接口方法与具体类型中对应的方法的映射的复杂度为O(ni*nt)，但是可以优化至*O(ni+nt)*的复杂度 ","date":"2021-06-17","objectID":"/interface_in_go/:3:0","tags":["Go","interface"],"title":"interface in go","uri":"/interface_in_go/"},{"categories":["Go"],"content":"参考 https://research.swtch.com/ https://blog.go-zh.org/laws-of-reflection https://blog.golang.org/laws-of-reflection ","date":"2021-06-17","objectID":"/interface_in_go/:4:0","tags":["Go","interface"],"title":"interface in go","uri":"/interface_in_go/"},{"categories":["evm"],"content":"Hyperledger Burrow是Hyperledger下的一个子项目，它实现了符合以太坊规范的EVM，这篇文章中对evm及相关代码进行了分析 ","date":"2021-05-23","objectID":"/burrow-evm/:0:0","tags":["evm"],"title":"Hyperledger Burrow中的evm及相关组件源码分析","uri":"/burrow-evm/"},{"categories":["evm"],"content":"acm acm中包含了账户以及账户状态相关的代码 该文件夹的名称大概来源于“account management” ","date":"2021-05-23","objectID":"/burrow-evm/:1:0","tags":["evm"],"title":"Hyperledger Burrow中的evm及相关组件源码分析","uri":"/burrow-evm/"},{"categories":["evm"],"content":"acmstate state.go state.go 中定义了两个hash值类型以及对应的编码/解码操作，还定义了对账户、存储、元数据的读/写/遍历操作接口 Metadatahash，表示元数据的hash，用于元数据寻址，为256位的字节数组；Codehash，表示账户中存储的代码的hash，用于CODEHASH指令，为256为字节数组。 // MetadataHash is the keccak hash for the metadata. This is to make the metadata content-addressed type MetadataHash [32]byte // CodeHash is the keccak hash for the code for an account. This is used for the EVM CODEHASH opcode, and to find the // correct Metadata for a contract type CodeHash [32]byte 最常使用的接口为ReaderWriter接口，也就是evm在执行时所需的第一个参数，它包括了对于账户和存储的读写操作 // Read and write account and storage state type ReaderWriter interface { Reader Writer } // Read-only account and storage state type Reader interface { AccountGetter StorageGetter } type Writer interface { AccountUpdater StorageSetter } type AccountGetter interface { // Get an account by its address return nil if it does not exist (which should not be an error) GetAccount(address crypto.Address) (*acm.Account, error) } type StorageGetter interface { // Retrieve a 32-byte value stored at key for the account at address, return Zero256 if key does not exist but // error if address does not GetStorage(address crypto.Address, key binary.Word256) (value []byte, err error) } type AccountUpdater interface { // Updates the fields of updatedAccount by address, creating the account // if it does not exist UpdateAccount(updatedAccount *acm.Account) error // Remove the account at address RemoveAccount(address crypto.Address) error } type StorageSetter interface { // Store a 32-byte value at key for the account at address, setting to Zero256 removes the key SetStorage(address crypto.Address, key binary.Word256, value []byte) error } state.go 中还定义了一个函数用于获取全局账户权限 // Get global permissions from the account at GlobalPermissionsAddress func GlobalAccountPermissions(getter AccountGetter) (permission.AccountPermissions, error) { acc, err := getter.GetAccount(acm.GlobalPermissionsAddress) if err != nil { return permission.AccountPermissions{}, err } if acc == nil { return permission.AccountPermissions{}, fmt.Errorf(\"global permissions account is not defined but must be\") } return acc.Permissions, nil } 全局账户权限地址定义在account.go中，为零值地址，该地址的权限字段包含了账户允许设置的全部权限 state_cache.go state_cache.go 定义了缓存的类型，对缓存内容的操作以及将缓存内容写回的方法。 type Cache struct { sync.RWMutex //读写锁 name string //缓存名称 backend Reader //读操作接口，包括读取账户和读取存储 accounts map[crypto.Address]*accountInfo //具体缓存的内容 readonly bool //只读标志位 } type accountInfo struct { sync.RWMutex //读写锁 account *acm.Account //账户 storage map[binary.Word256][]byte //账户的存储 removed bool //账户是否已经移除 updated bool //账户是否需要更新 } type CacheOption func(*Cache) *Cache //使用示例如ReadOnly var ReadOnly CacheOption = func(cache *Cache) *Cache { cache.readonly = true return cache } Cache实现了ReaderWriter接口，但是所有方法均是对缓存中的accountInfo进行操作，每种方法都会先检查账户/存储是否在缓存中，如果没有，则将其加入缓存 // Syncs changes to the backend in deterministic order. Sends storage updates before updating // the account they belong so that storage values can be taken account of in the update. func (cache *Cache) Sync(st Writer) error { if cache.readonly { // Sync is (should be) a no-op for read-only - any modifications should have been caught in respective methods return nil } cache.Lock() defer cache.Unlock() var addresses crypto.Addresses for address := range cache.accounts { addresses = append(addresses, address) } sort.Sort(addresses) for _, address := range addresses { accInfo := cache.accounts[address] accInfo.RLock() if accInfo.removed { err := st.RemoveAccount(address) if err != nil { return err } } else if accInfo.updated { // First update account in case it needs to be created err := st.UpdateAccount(accInfo.account) if err != nil { return err } // Sort keys var keys binary.Words256 for key := range accInfo.storage { keys = append(keys, key) } sort.Sort(keys) // Update account's storage for _, key := range keys { value := accInfo.storage[key] err := st.SetStorage(address, key, value) if err != nil { return err } } } accInfo.RUnlock() } return nil } Cache包含一个Sync方法","date":"2021-05-23","objectID":"/burrow-evm/:1:1","tags":["evm"],"title":"Hyperledger Burrow中的evm及相关组件源码分析","uri":"/burrow-evm/"},{"categories":["evm"],"content":"execution execution 中包含了执行环境相关代码 ","date":"2021-05-23","objectID":"/burrow-evm/:2:0","tags":["evm"],"title":"Hyperledger Burrow中的evm及相关组件源码分析","uri":"/burrow-evm/"},{"categories":["evm"],"content":"engine account.go account.go 中定义了部署合约代码、部署WASM代码、修改账户状态相关的函数，这些函数被用于contract.go的指令执行中 accounts.go accounts.go 中定义了获取账户、创建账户、权限检查相关的函数 func EnsurePermission(callFrame *CallFrame, address crypto.Address, perm permission.PermFlag) error { hasPermission, err := HasPermission(callFrame, address, perm) if err != nil { return err } else if !hasPermission { return errors.PermissionDenied{ Address: address, Perm: perm, } } return nil } // CONTRACT: it is the duty of the contract writer to call known permissions // we do not convey if a permission is not set // (unlike in state/execution, where we guarantee HasPermission is called // on known permissions and panics else) // If the perm is not defined in the acc nor set by default in GlobalPermissions, // this function returns false. func HasPermission(st acmstate.Reader, address crypto.Address, perm permission.PermFlag) (bool, error) { acc, err := st.GetAccount(address) if err != nil { return false, err } if acc == nil { return false, fmt.Errorf(\"account %v does not exist\", address) } globalPerms, err := acmstate.GlobalAccountPermissions(st) if err != nil { return false, err } perms := acc.Permissions.Base.Compose(globalPerms.Base) value, err := perms.Get(perm) if err != nil { return false, err } return value, nil } 这里权限检查是通过调用state.go中的GlobalAccountPermissions函数来获取作为基准的权限，然后检查该账户设置的基准权限中是否包含目标权限 blockchain.go blockchain.go 中定义了一个实现了Blockchain接口的TestBlockChain类型用于测试 call_frame.go call_frame.go 中定义了 CallFrame 结构体，相当于一个调用栈 type CallFrame struct { // Cache this State wraps *acmstate.Cache // Where we sync backend acmstate.ReaderWriter // In order for nested cache to inherit any options cacheOptions []acmstate.CacheOption // Depth of the call stack callStackDepth uint64 // Max call stack depth maxCallStackDepth uint64 } // Create a new CallFrame to hold state updates at a particular level in the call stack func NewCallFrame(st acmstate.ReaderWriter, cacheOptions ...acmstate.CacheOption) *CallFrame { return newCallFrame(st, 0, 0, cacheOptions...) } func newCallFrame(st acmstate.ReaderWriter, stackDepth uint64, maxCallStackDepth uint64, cacheOptions ...acmstate.CacheOption) *CallFrame { return \u0026CallFrame{ Cache: acmstate.NewCache(st, cacheOptions...), backend: st, cacheOptions: cacheOptions, callStackDepth: stackDepth, maxCallStackDepth: maxCallStackDepth, } } ... func (st *CallFrame) NewFrame(cacheOptions ...acmstate.CacheOption) (*CallFrame, error) { if st.maxCallStackDepth \u003e 0 \u0026\u0026 st.maxCallStackDepth == st.callStackDepth { return nil, errors.Codes.CallStackOverflow } return newCallFrame(st.Cache, st.callStackDepth+1, st.maxCallStackDepth, append(st.cacheOptions, cacheOptions...)...), nil } func (st *CallFrame) Sync() error { err := st.Cache.Sync(st.backend) if err != nil { return errors.AsException(err) } return nil } NewCallFrame函数暴露给外界用于创建新的CallFrame，该函数接受两个参数：实现了ReaderWriter接口的类型和任意多个CacheOption，并调用内部函数nameCallFrame来创建CallFrame newCallFrame会根据传入的参数创建一个Cache，用于缓存账户及存储信息 使用NewFrame创建新的CallFrame时，会继承当前CallFrame的值，并将当前栈高度值加一，使其看起来就像在调用栈中压入了一个新的调用 CallFrame包含一个Sync方法，用于将缓存写回，其内部会调用Cache的Sync()方法执行写回操作 call.go call.go中实现了一个Call函数，为所有Callable.Call接口的实现类型提供了一层封装： // Call provides a standard wrapper for implementing Callable.Call with appropriate error handling and event firing. func Call(state State, params CallParams, execute func(State, CallParams) ([]byte, error)) ([]byte, error) { maybe := new(errors.Maybe) if params.CallType == exec.CallTypeCall || params.CallType == exec.CallTypeCode { // NOTE: Delegate and Static CallTypes do not transfer the value to the callee. maybe.PushError(Transfer(state.CallFrame, params.Caller, params.Callee, \u0026params.Value)) } output := maybe.Bytes(execute(state, params)) // fire the post call event (including exception if applicable) and make sure we return the accumulated call error maybe.PushError(FireCallEvent(state.CallFrame, maybe.Error(), state.EventSink, output, params)) return output, maybe.Error() } 其中第三个参数execute就是定义了具体的执行过程的函数，在burrow中，合约调用/原生合约/原生函数/","date":"2021-05-23","objectID":"/burrow-evm/:2:1","tags":["evm"],"title":"Hyperledger Burrow中的evm及相关组件源码分析","uri":"/burrow-evm/"},{"categories":["evm"],"content":"evm abi abi.go // Struct reflection // SpecFromStructReflect generates a FunctionSpec where the arguments and return values are // described a struct. Both args and rets should be set to the return value of reflect.TypeOf() // with the respective struct as an argument. //对结构体的每个字段都构造一个Arguement类型，用Arguement切片来表示一个结构体 func SpecFromStructReflect(fname string, args reflect.Type, rets reflect.Type) *FunctionSpec { inputs := make([]Argument, args.NumField()) outputs := make([]Argument, rets.NumField()) for i := 0; i \u003c args.NumField(); i++ { f := args.Field(i) a := typeFromReflect(f.Type) a.Name = f.Name inputs[i] = a } for i := 0; i \u003c rets.NumField(); i++ { f := rets.Field(i) a := typeFromReflect(f.Type) a.Name = f.Name outputs[i] = a } return NewFunctionSpec(fname, inputs, outputs) } func typeFromReflect(v reflect.Type) Argument { arg := Argument{Name: v.Name()} if v == reflect.TypeOf(crypto.Address{}) { arg.EVM = EVMAddress{} } else if v == reflect.TypeOf(big.Int{}) { arg.EVM = EVMInt{M: 256} } else { if v.Kind() == reflect.Array { //如果v是Array类型，需要设置以下两个字段 arg.IsArray = true arg.ArrayLength = uint64(v.Len()) //将v设置为其存储的元素的类型 v = v.Elem() } else if v.Kind() == reflect.Slice { arg.IsArray = true v = v.Elem() } switch v.Kind() { case reflect.Bool: arg.EVM = EVMBool{} case reflect.String: arg.EVM = EVMString{} case reflect.Uint64: arg.EVM = EVMUint{M: 64} case reflect.Int64: arg.EVM = EVMInt{M: 64} default: panic(fmt.Sprintf(\"no mapping for type %v\", v.Kind())) } } return arg } SpecFromStructReflect函数接收两个reflect.Type类型，代表参数和返回值的类型，实际均为结构体类型，函数内部调用typeFromRelect函数对每个字段进行处理，将其转换为Arguement类型，根据字段的实际类型设置EVMType实现类型，并保存至对应输入和输出的Arguement切片中，然后构造一个FunctionSpec类型并返回 event_spec.go // Argument is a decoded function parameter, return or event field type Argument struct { Name string EVM EVMType IsArray bool Indexed bool Hashed bool ArrayLength uint64 } Arguement类型被用于描述函数的参数/返回值或者event的输入，其中的EVM字段为EVMType类型 function_spec.go // FunctionIDSize is the length of the function selector const FunctionIDSize = 4 type FunctionSpec struct { Name string FunctionID FunctionID Constant bool Inputs []Argument Outputs []Argument } type FunctionID [FunctionIDSize]byte FunctionSpec类型定义了描述一个Function需要的值，包括函数名、ID、输入的参数的类型和数量、输出的返回值的类型和数量，其中ID为固定4字节长度，输入与输出字段均为Arguement切片 packing.go packing.go 中定义了编码/解码的具体函数 func Pack(argSpec []Argument, args ...interface{}) ([]byte, error) { getArg, err := argGetter(argSpec, args, false) if err != nil { return nil, err } return pack(argSpec, getArg) } func Unpack(argSpec []Argument, data []byte, args ...interface{}) error { getArg, err := argGetter(argSpec, args, true) if err != nil { return err } return unpack(argSpec, data, getArg) } func argGetter(argSpec []Argument, args []interface{}, ptr bool) (func(int) interface{}, error) { if len(args) == 1 { rv := reflect.ValueOf(args[0]) if rv.Kind() == reflect.Ptr { rv = rv.Elem() } else if ptr { return nil, fmt.Errorf(\"struct pointer required in order to set values, but got %v\", rv.Kind()) } if rv.Kind() != reflect.Struct { if len(args) == 1 { // Treat s single arg return func(i int) interface{} { return args[i] }, nil } return nil, fmt.Errorf(\"expected single argument to be struct but got %v\", rv.Kind()) } fields := rv.NumField() if fields != len(argSpec) { return nil, fmt.Errorf(\"%d arguments in struct expected, %d received\", len(argSpec), fields) } if ptr { return func(i int) interface{} { return rv.Field(i).Addr().Interface() }, nil } return func(i int) interface{} { return rv.Field(i).Interface() }, nil } if len(args) == len(argSpec) { return func(i int) interface{} { return args[i] }, nil } return nil, fmt.Errorf(\"%d arguments expected, %d received\", len(argSpec), len(args)) } Pack、Unpack是对外暴露的函数 Unpack接收三个参数，argSpec为Argument切片类型，表示待解码数据的类型，data存储待解码的数据，args用来存储解码后的数据 argGetter返回一个函数 func(int) interface{} 用来为argSpec中的每个Argument分配一个储解码后的数据的类型，也就是argSpec和args的对应关系，如果二者长度相等，就是顺序对应，如果args长度为1，则判断其是否为结构体类型，若是则按照结构体字段顺序与argSpec对应，否则报错 Unpack调用argGetter函数获取用于返回与argSpec中每个Argument对应的类型","date":"2021-05-23","objectID":"/burrow-evm/:2:2","tags":["evm"],"title":"Hyperledger Burrow中的evm及相关组件源码分析","uri":"/burrow-evm/"},{"categories":["evm"],"content":"native native 与原生合约有关，这里的原生合约(native contracts)的功能类似于以太坊evm中预编译好的合约，默认包括对于账户权限的操作和加密操作 contract.go contract.go 中规定了原生合约声明函数的的规范，函数必须声明为以下形式： func unsetBase(context Context, args unsetBaseArgs) (unsetBaseRets, error) {} 必须有一个或两个参数以及两个返回值，第一个参数必须是 Context 类型： // Context is the first argument to any native function. This struct carries // all the context an native needs to access e.g. state in burrow. type Context struct { State engine.State engine.CallParams // TODO: this allows us to call back to EVM contracts if we wish - make use of it somewhere... externals engine.Dispatcher Logger *logging.Logger } 第二个参数以及第一个返回值必须是结构体类型，与solidity函数中的参数与返回值一一对应，第二个返回值必须是error类型 // Contract is metadata for native contract. Acts as a call target // from the EVM. Can be used to generate bindings in a smart contract languages. type Contract struct { // Comment describing purpose of native contract and reason for assembling // the particular functions Comment string // Name of the native contract Name string functionsByID map[abi.FunctionID]*Function functions []*Function address crypto.Address logger *logging.Logger } var _ engine.Native = \u0026Contract{} Contract结构体类型实现了engine.Native接口，包含一个Function列表，实际执行均由Function进行，Contract对Function进行了一层包装 // Dispatch is designed to be called from the EVM once a native contract // has been selected. func (c *Contract) Call(state engine.State, params engine.CallParams) (output []byte, err error) { if len(params.Input) \u003c abi.FunctionIDSize { return nil, errors.Errorf(errors.Codes.NativeFunction, \"Burrow Native dispatch requires a 4-byte function identifier but arguments are only %v bytes long\", len(params.Input)) } var id abi.FunctionID copy(id[:], params.Input) function, err := c.FunctionByID(id) if err != nil { return nil, err } params.Input = params.Input[abi.FunctionIDSize:] return function.Call(state, params) } // Get function by calling identifier FunctionSelector func (c *Contract) FunctionByID(id abi.FunctionID) (*Function, errors.CodedError) { f, ok := c.functionsByID[id] if !ok { return nil, errors.Errorf(errors.Codes.NativeFunction, \"unknown native function with ID %x\", id) } return f, nil } Contract类型实现了Callable接口，其Call函数内部根据param中的Input字段获取FunctionID并获取相应的Function，然后调用Function中的Call函数执行 function.go // Function is metadata for native functions. Act as call targets // for the EVM when collected into an Contract. Can be used to generate // bindings in a smart contract languages. type Function struct { // Comment describing function's purpose, parameters, and return value Comment string // Permissions required to call function PermFlag permission.PermFlag // Whether this function writes to state Pure bool // Native function to which calls will be dispatched when a containing F interface{} // Following fields are for only for memoization // The name of the contract to which this function belongs (if any) contractName string // Function name (used to form signature) name string // The abi abi *abi.FunctionSpec // Address of containing contract address crypto.Address externals engine.Dispatcher logger *logging.Logger } var _ engine.Native = \u0026Function{} Function类型也实现了engine.Native接口，其中的F字段即为native function，也就是由go语言实现的函数 // Created a new function mounted directly at address (i.e. no Solidity contract or function selection) func NewFunction(comment string, address crypto.Address, permFlag permission.PermFlag, f interface{}) (*Function, error) { function := \u0026Function{ Comment: comment, PermFlag: permFlag, F: f, } err := function.init(address) if err != nil { return nil, err } return function, nil } func (f *Function) init(address crypto.Address) error { // Get name of function t := reflect.TypeOf(f.F) v := reflect.ValueOf(f.F) // v.String() for functions returns the empty string fullyQualifiedName := runtime.FuncForPC(v.Pointer()).Name() a := strings.Split(fullyQualifiedName, \".\") f.name = a[len(a)-1] if t.NumIn() != 1 \u0026\u0026 t.NumIn() != 2 { return fmt.Errorf(\"native function %s must have a one or two arguments\", fu","date":"2021-05-23","objectID":"/burrow-evm/:2:3","tags":["evm"],"title":"Hyperledger Burrow中的evm及相关组件源码分析","uri":"/burrow-evm/"},{"categories":["evm"],"content":"参考链接 Golang的反射reflect深入理解和示例 反射三法则 ","date":"2021-05-23","objectID":"/burrow-evm/:3:0","tags":["evm"],"title":"Hyperledger Burrow中的evm及相关组件源码分析","uri":"/burrow-evm/"},{"categories":["Go"],"content":"本文翻译自https://blog.golang.org/slices","date":"2021-05-05","objectID":"/slices_in_go/","tags":["Go","切片"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"注意 本文翻译自https://blog.golang.org/slices 过程式编程语言最常见的特性之一便是数组的概念。数组看起来很简单，但是当把它加进一门语言里时，需要考虑很多问题，例如： 固定大小 or 可变大小？ 数组的大小要作为数组类型的一部分吗？ 多维数组看起来是什么样的？ 空数组有意义吗？ … 数组是语言的一个特性还是其设计的关键部分将取决于这些问题的答案。 在go的早期开发过程中，花了一年的时间来决定这些问题的答案。其中关键的一步便是引入了切片，它构建在固定大小的数组上，提供了灵活、可扩展的数据结构。然而，直到今天，受到来自于其他编程语言的经验的影响，刚接触go的程序员往往会掉进切片的工作方式这个大坑里。 这篇文章将会解释 slice 以及内置函数 append 是如何工作的，以及这样设计的原因。 ","date":"2021-05-05","objectID":"/slices_in_go/:0:0","tags":["Go","切片"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"Arrays 数组是go语言中一个重要的构建模块，但是如建筑物的地基一样，它通常隐藏在更多的可见组件之下。在讨论切片的其他更有趣，更强大，更突出的概念之前，我们必须先简要的讨论一下数组。 数组在go语言中并不常见，因为数组的大小是它的类型的一部分。也就是说，我们在声明一个数组时，必须指定它的大小，这限制了数组的表达能力。 var buffer [256]byte 上面的表达式声明了一个变量 buffer ，它包含256个字节。 buffer 的类型声明包含了它的大小，[256]byte。而一个包含512个字节的数组变量类型是[512]byte。 包含在一个数组中的数据在内存中看起来是这样的： buffer: byte byte byte ...... byte byte byte 我们可以通过索引来访问 buffer 中的元素，例如 buffer[0] ， buffer[1] ，直到 buffer[255] 。越界访问buffer将导致程序崩溃。 内置函数 len() 可以返回数组或者切片或者其他某些数据类型中包含的元素的数量， len(buffer) 返回固定值256 数组有它自己的用处，比如数组很好的表示了转换矩阵，但是在go语言中他们更多的被用来为切片保留存储空间 ","date":"2021-05-05","objectID":"/slices_in_go/:1:0","tags":["Go","切片"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"Slices: The slice header 想要更好的使用切片，我们必须明白切片是什么以及切片可以做什么 切片是一种数据结构，它描述了一个数组中的一段连续的数据，数组与切片并不占用同一块存储空间。一个切片并不是一个数组。切片描述了数组的一个片段。 继续使用上一节中的数组变量 buffer ，我们可以通过切分（slicing）这个数组来创造一个描述 buffer 中的第100-150个元素（不包括第150个元素）的切片： var slice []byte = buffer[100:150] 变量 slice 的类型为 []byte ，读作\"slice of bytes\"。 slice 通过切分数组 buffer 的第100到第150个元素来完成初始化。更常用的语法是去掉类型部分，根据初始化表达式设置类型： var slice = buffer[100:150] 在函数内部，我们可以使用短变量声明： slice := buffer[100:150] 注意只能在函数内部使用短变量声明，因为函数外的每条语句都必须以关键字开始（var，func等）。 现在可以把切片看作一个拥有两个元素的数据结构：长度以及指向数组中某个元素的指针。可以把切片想象成这样的一个结构体： type sliceHeader struct { Length int ZerothElement *byte } slice := sliceHeader{ Length: 50, ZerothElement: \u0026buffer[100], } 当然，这只是一个为了便于理解做出的假设示例。尽管上面这段代码表明 sliceHeader 类型对程序猿是不可见的，并且指针的类型取决于它所指向的元素的类型，但是这给了我们关于切片机制的大体思路。 目前为止我们已经在数组上进行了切片操作，但是我们还可以在切片上进行切片操作，就像这样： slice2 := slice[5:10] 就像之前的切片操作一样，上面的语句创建了一个新的切片， slice2 包括了 slice 中的第5-9（不含）个元素，也就是数组 buffer 中的第105-109（不含）个元素。 slice2 底层的 sliceHeader 看起来是这样的： slice2 := sliceHeader{ Length: 5, ZerothElement: \u0026buffer[105], } 注意此时 slice2 的 sliceHeader 仍然指向相同的底层数组，也就是 buffer 。 我们也可以重切片（reslice），也就是对一个切片进行切片操作，并将结果存储在原始的切片结构中： slice = slice[5:10] 此时 slice 的 sliceHeader 和上面的 slice2 的 sliceHeader 看起来是一样的。重切片操作应用的更多，例如截断一个切片。下面这条语句删除了切片的第一个和最后一个元素： slice = slice[1:len(slice)-1] 你可能经常会听到老手程序猿谈论关于“切片头”的问题，因为那确实是存储在切片变量中的内容，也就是说，一个切片实际上就是上面所描述的一个切片头结构体。例如，当你调用一个以切片作为参数的函数时，比如bytes.IndexRune，就会给这个函数传递一个切片头结构体。在下面这条语句中， slashPos := bytes.IndexRune(slice, '/') 传给 IndexRune 的参数 slice ，其实是一个切片头结构体 切片头结构体中还有一个元素，我们将会在下面讨论，但是首先我们先来看一下当我们使用切片时，切片头的存在意味着什么。 ","date":"2021-05-05","objectID":"/slices_in_go/:2:0","tags":["Go","切片"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"Passing slices to functions 即使切片包含一个指针，切片本身也是一个值，理解这点很重要。实际上，它是一个结构体值，包含一个指针和一个长度值。它不是一个指向结构体的指针。 👆上面这点很重要👆 上一个例子中当我们调用 IndexRune 时，它实际上接收的是一个切片头结构体的副本。这种行为有很重大的影响。 考虑这样一个简单的函数： func AddOneToEachElement(slice []byte) { for i := range slice { slice[i]++ } } 就像他的函数名一样，这个函数会遍历整个切片，并将切片中的每个元素加一。 func main() { slice := buffer[10:20] for i := 0; i \u003c len(slice); i++ { slice[i] = byte(i) } fmt.Println(\"before\", slice) AddOneToEachElement(slice) fmt.Println(\"after\", slice) } 运行结果为： before [0 1 2 3 4 5 6 7 8 9] after [1 2 3 4 5 6 7 8 9 10] 尽管切片是以切片头结构体值传递的方式传入的，但是切片头结构体包含了一个指向底层数组的指针，所以不管是原始的切片还是作为参数传递的切片副本都包含了指向相同的底层数组的指针。因此，当上面的函数返回时，我们可以通过原始切片观察到元素的改动。 下面这个例子展示了传递给函数的参数是副本： func SubtractOneFromLength(slice []byte) []byte { slice = slice[0 : len(slice)-1] return slice } func main() { fmt.Println(\"Before: len(slice) =\", len(slice)) newSlice := SubtractOneFromLength(slice) fmt.Println(\"After: len(slice) =\", len(slice)) fmt.Println(\"After: len(newSlice) =\", len(newSlice)) } Before: len(slice) = 50 After: len(slice) = 50 After: len(newSlice) = 49 我们可以看到当切片作为参数传入时，函数可以修改它包含的内容，也就是它指向的底层数组中的值，但是无法修改它的切片头结构体中元素的值。存储在 slice 中的长度值并没有被修改，上面的函数只是修改了传入的切片头结构体的副本，而不是其本体。这样如果我们想写一个函数修改切片头的话，我们就需要将修改后的副本作为结果返回。在上面的例子中， slice 并没有改变，但是返回值 newSlice 的长度被修改了。 ","date":"2021-05-05","objectID":"/slices_in_go/:3:0","tags":["Go","切片"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"Pointers to slices: Method receivers 另一种在函数中修改切片头的方法是将切片的指针作为参数传入。下面是上一个例子的变体： func PtrSubtractOneFromLength(slicePtr *[]byte) { slice := *slicePtr *slicePtr = slice[0 : len(slice)-1] } func main() { fmt.Println(\"Before: len(slice) =\", len(slice)) PtrSubtractOneFromLength(\u0026slice) fmt.Println(\"After: len(slice) =\", len(slice)) } 它的运行结果为： Before: len(slice) = 50 After: len(slice) = 49 这个例子看起来很麻烦，需要处理间接引用（例子里面引入了一个临时变量来帮助处理），但是有一种常见的情况下你可以看到切片指针，即，通常使用指针作为修改切片的方法的接收者。 我们假设一个切片，这个切片拥有一个在最后一个斜杠处截断它的方法。我们可以这样写： type path []byte func (p *path) TruncateAtFinalSlash() { i := bytes.LastIndex(*p, []byte(\"/\")) if i \u003e= 0 { *p = (*p)[0:i] } } func main() { pathName := path(\"/usr/bin/tso\") // Conversion from string to path. pathName.TruncateAtFinalSlash() fmt.Printf(\"%s\\n\", pathName) } 其结果为： /usr/bin 如果我们将这个例子里的接收者类型由指针改为值呢？ type path []byte func (p path) TruncateAtFinalSlash() { i := bytes.LastIndex(p, []byte(\"/\")) if i \u003e= 0 { p = (p)[0:i] } } func main() { pathName := path(\"/usr/bin/tso\") // Conversion from string to path. pathName.TruncateAtFinalSlash() fmt.Printf(\"%s\\n\", pathName) } 此时运行结果为： /usr/bin/tso 方法是一类带有特殊的接收者参数的函数，接收者也是个参数，因此，如果使用值接收者，方法会对原始值的副本进行操作。 但是，当接收者是切片类型时，那么不管是使用值接收者还是指针接收者，我们都可以对底层数组进行修改，因为二者都包含了指向同一个底层数组的指针 看这样一个例子，将 path 中的小写字母转换为大写字母： type path []byte func (p path) ToUpper() { for i, b := range p { if 'a' \u003c= b \u0026\u0026 b \u003c= 'z' { p[i] = b + 'A' - 'a' } } } func main() { pathName := path(\"/usr/bin/tso\") pathName.ToUpper() fmt.Printf(\"%s\\n\", pathName) } 使用值接收者，依然可以完成修改操作： /USR/BIN/TSO 使用指针接收者也会得到同样的结果： func (p *path) ToUpper() { for i, b := range *p { if 'a' \u003c= b \u0026\u0026 b \u003c= 'z' { (*p)[i] = b + 'A' - 'a' } } } ","date":"2021-05-05","objectID":"/slices_in_go/:4:0","tags":["Go","切片"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"Capacity 下面这个函数将它参数中的切片扩展了一个指定的元素： func Extend(slice []int, element int) []int { n := len(slice) slice = slice[0 : n+1] slice[n] = element return slice } （为什么需要返回修改后的切片呢？）现在我们运行它： func main() { var iBuffer [10]int slice := iBuffer[0:0] for i := 0; i \u003c 20; i++ { slice = Extend(slice, i) fmt.Println(slice) } } 会得到这样的结果： [0] [0 1] [0 1 2] [0 1 2 3] [0 1 2 3 4] [0 1 2 3 4 5] [0 1 2 3 4 5 6] [0 1 2 3 4 5 6 7] [0 1 2 3 4 5 6 7 8] [0 1 2 3 4 5 6 7 8 9] panic: runtime error: slice bounds out of range [:11] with capacity 10 goroutine 1 [running]: main.Extend(...) /tmp/sandbox070713439/prog.go:16 main.main() /tmp/sandbox070713439/prog.go:25 +0x105 现在我们需要讨论一下之前提到的切片头结构体的第三个元素了：它的容量（capacity）。除了数组指针和长度，切片头结构体中还存储了切片的容量值： type sliceHeader struct { Length int Capacity int ZerothElement *byte } 容量字段记录了底层数组实际拥有多少空间，它的值就是长度字段可以达到的最大值。当我们试图扩展切片超过它的容量值时，就会造成数组的越界访问，从而导致程序报错（就像上面这个例子一样）。 上面这个例子中我们创建了这样一个切片： slice := iBuffer[0:0] 它的切片头结构体看起来是这样的： slice := sliceHeader{ Length: 0, Capacity: 10, ZerothElement: \u0026iBuffer[0], } 它的容量值等于它指向的底层数组 iBuffer 的长度减去切片指向的第一个元素的索引值（在本例中这个值为0）。可以使用内置函数 cap() 来获得切片的容量： if cap(slice) == len(slice) { fmt.Println(\"slice is full!\") } ","date":"2021-05-05","objectID":"/slices_in_go/:5:0","tags":["Go","切片"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"Make 根据定义，切片的容量值限制了切片可扩展的长度，我们无法扩展一个切片超过它的容量。但是我们可以使用这样的操作来实现这一目的：分配一个新数组，将原数组数据复制过来，然后修改切片使其指向新的数组。 下面我们来尝试一下。我们可以使用 new() 函数来分配一个更大的数组然后切片，但是使用 make() 函数来代替上述操作更加简单。他一次性完成了分配了一个新的数组并且在数组之上创建了一个切片的操作。 make() 函数接受三个参数：切片类型，它的初始长度，和它的容量，也就是 make 创建的新数组的长度。下面的语句创建了长度为10，容量为15的切片： slice := make([]int, 10, 15) fmt.Printf(\"len: %d, cap: %d\\n\", len(slice), cap(slice)) 运行结果为： len: 10, cap: 15 下面这段代码使切片的容量翻倍，长度不变： slice := make([]int, 10, 15) fmt.Printf(\"len: %d, cap: %d\\n\", len(slice), cap(slice)) newSlice := make([]int, len(slice), 2*cap(slice)) for i := range slice { newSlice[i] = slice[i] } slice = newSlice fmt.Printf(\"len: %d, cap: %d\\n\", len(slice), cap(slice)) 运行结果为： len: 10, cap: 15 len: 10, cap: 30 当创建切片时，长度和容量值通常是相同的。 make 函数对于这种情况有一个简写： gophers := make([]Gopher, 10) 切片 gophere 的长度和容量均为10 ","date":"2021-05-05","objectID":"/slices_in_go/:6:0","tags":["Go","切片"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"Copy 上一节的例子中我们使用了一个循环来将数据复制到新的切片中。 Go 提供了一个函数 copy 来使复制过程更加简单。它的参数是两个切片，将数据从第二个切片中复制到第一个切片中： newSlice := make([]int, len(slice), 2*cap(slice)) copy(newSlice, slice) copy 函数只复制它能够复制的值，也就是说，它复制的元素数量是两个切片的长度中的的最小值。它返回值一个 int 值，代表它复制的元素的数量。 当 copy 的两个参数是同一个值时，他依然可以正确的操作，也就是说我们可以使用 copy 在一个切片中移动元素。下面这个例子展示了如何使用 copy 在切片指定位置插入一个值： // Insert inserts the value into the slice at the specified index, // which must be in range. // The slice must have room for the new element. func Insert(slice []int, index, value int) []int { // Grow the slice by one element. slice = slice[0 : len(slice)+1] // Use copy to move the upper part of the slice out of the way and open a hole. copy(slice[index+1:], slice[index:]) // Store the new value. slice[index] = value // Return the result. return slice } 关于这个函数有几件事需要注意：首先，它必须返回一个新的切片，因为切片的长度值已经被修改了；其次，它使用了简写 slice[i:] ，等同于 slice[i:len(slice)] ，当然我们也可以忽略这个表达式的第一个值，它默认为0，也就是 slice[:] ，它代表这个切片本身。当我们创建一个拥有数组全部元素的切片时，我们就可以这么写：array[:] 。 好了，现在我们来运行一下上面这个例子： slice := make([]int, 10, 20) // Note capacity \u003e length: room to add element. for i := range slice { slice[i] = i } fmt.Println(slice) slice = Insert(slice, 5, 99) fmt.Println(slice) 运行结果为： [0 1 2 3 4 5 6 7 8 9] [0 1 2 3 4 99 5 6 7 8 9] ","date":"2021-05-05","objectID":"/slices_in_go/:7:0","tags":["Go","切片"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"Append: An example 在Capacity那一节中，我们写了个 Extend 函数来为切片扩展一个元素。程序在运行时会报错，因为我们设定的切片的容量太小，导致底层数组越界访问造成程序崩溃。现在我们已经解决了这一问题，可以编写一个健壮的 Extend 的实现： func Extend(slice []int, element int) []int { n := len(slice) if n == cap(slice) { // Slice is full; must grow. // We double its size and add 1, so if the size is zero we still grow. newSlice := make([]int, len(slice), 2*len(slice)+1) copy(newSlice, slice) slice = newSlice } slice = slice[0 : n+1] slice[n] = element return slice } 这个例子中我们返回了一个切片，因为与原切片相比，返回的切片实际上指向了我们重新分配的底层数组，与原切片完全不同。下面这段代码展示了切片在填充过程中发生了什么： slice := make([]int, 0, 5) for i := 0; i \u003c 10; i++ { slice = Extend(slice, i) fmt.Printf(\"len=%d cap=%d slice=%v\\n\", len(slice), cap(slice), slice) fmt.Println(\"address of 0th element:\", \u0026slice[0]) } 其结果为： len=1 cap=5 slice=[0] address of 0th element: 0xc00007a030 len=2 cap=5 slice=[0 1] address of 0th element: 0xc00007a030 len=3 cap=5 slice=[0 1 2] address of 0th element: 0xc00007a030 len=4 cap=5 slice=[0 1 2 3] address of 0th element: 0xc00007a030 len=5 cap=5 slice=[0 1 2 3 4] address of 0th element: 0xc00007a030 len=6 cap=11 slice=[0 1 2 3 4 5] address of 0th element: 0xc000062060 len=7 cap=11 slice=[0 1 2 3 4 5 6] address of 0th element: 0xc000062060 len=8 cap=11 slice=[0 1 2 3 4 5 6 7] address of 0th element: 0xc000062060 len=9 cap=11 slice=[0 1 2 3 4 5 6 7 8] address of 0th element: 0xc000062060 len=10 cap=11 slice=[0 1 2 3 4 5 6 7 8 9] address of 0th element: 0xc000062060 原始数组容量只有5，当原始数组被填满时，重新分配了一个容量为11的数组，此时第0个元素的地址也改变了。 根据这个例子的思路，我们可以写一个更好的函数 Append 来为切片一次性扩充多个元素。这我们会用到 Go 语言的可变参数函数，在声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号“…”，这表示该函数会接收任意数量的该类型参数。 作为最初的实现，我们可以将对 Extend 进行多次调用。 Append 的函数签名如下： func Append(slice []int, items ...int) []int Append 函数接收一个切片以及任意多个 int 类型的元素，这些元素实际上被当成一个切片来进行处理： // Append appends the items to the slice. // First version: just loop calling Extend. func Append(slice []int, items ...int) []int { for _, item := range items { slice = Extend(slice, item) } return slice } 执行以下语句： slice := []int{0, 1, 2, 3, 4} fmt.Println(slice) slice = Append(slice, 5, 6, 7, 8) fmt.Println(slice) 其结果为： [0 1 2 3 4] [0 1 2 3 4 5 6 7 8] 注意到这里我们同时声明并初始化了一个切片： slice := []int{0, 1, 2, 3, 4} 我们不仅可以传入任意多个参数，还可以以切片的形式传入参数，不过必须在切片后面加上 ... ： slice1 := []int{0, 1, 2, 3, 4} slice2 := []int{55, 66, 77} fmt.Println(slice1) slice1 = Append(slice1, slice2...) // The '...' is essential! fmt.Println(slice1 其结果为： [0 1 2 3 4] [0 1 2 3 4 55 66 77] 我们可以改写一下重分配数组的条件，使其更有效率： // Append appends the elements to the slice. // Efficient version. func Append(slice []int, elements ...int) []int { n := len(slice) total := len(slice) + len(elements) if total \u003e cap(slice) { // Reallocate. Grow to 1.5 times the new size, so we can still grow. newSize := total*3/2 + 1 newSlice := make([]int, total, newSize) copy(newSlice, slice) slice = newSlice } slice = slice[:total] copy(slice[n:], elements) return slice } 这里我们使用了两次 copy ，一次用于将数据复制进新的数组，一次用于将新的数据复制到数组的末尾。这和最初的函数具有同样的效力。 ","date":"2021-05-05","objectID":"/slices_in_go/:8:0","tags":["Go","切片"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"Append: The build-in function 到此我们已经明白了内置函数 append 的设计动机。它和我们的 Append 相似，效率上也差不多，但是它适用于任何切片类型。 Go 语言的一个缺点是任何泛型操作必须由运行时提供。以后也许会改变，但是现在，为了使切片操作更加简单， Go 提供了内置的泛型 append 函数。它适用于任何类型。 由于切片头结构体经常会被 append 修改，你需要保存返回的切片值。事实上，编译器不允许你在不保存结果的情况下调用 append 。 下面是一些使用 append 的语句： // Create a couple of starter slices. slice := []int{1, 2, 3} slice2 := []int{55, 66, 77} fmt.Println(\"Start slice: \", slice) fmt.Println(\"Start slice2:\", slice2) // Add an item to a slice. slice = append(slice, 4) fmt.Println(\"Add one item:\", slice) // Add one slice to another. slice = append(slice, slice2...) fmt.Println(\"Add one slice:\", slice) // Make a copy of a slice (of int). slice3 := append([]int(nil), slice...) fmt.Println(\"Copy a slice:\", slice3) // Copy a slice to the end of itself. fmt.Println(\"Before append to self:\", slice) slice = append(slice, slice...) fmt.Println(\"After append to self:\", slice) 运行结果为： Start slice: [1 2 3] Start slice2: [55 66 77] Add one item: [1 2 3 4] Add one slice: [1 2 3 4 55 66 77] Copy a slice: [1 2 3 4 55 66 77] Before append to self: [1 2 3 4 55 66 77] After append to self: [1 2 3 4 55 66 77 1 2 3 4 55 66 77] 有必要花点时间思考一下最后一行的示例来理解切片的设计如何使这个操作正确的执行 在“Slice Tricks”有更多的关于 append 、copy 以及切片的其他用法的例子。 ","date":"2021-05-05","objectID":"/slices_in_go/:9:0","tags":["Go","切片"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"Nil 现在我们可以来看一下 nil 切片代表着什么。自然的，它代表着切片头结构体的零值： sliceHeader{ Length: 0, Capacity: 0, ZerothElement: nil, } 或者是： sliceHeader{} 注意此时指针的值也是 nil 。而由 array[0:0] 创建的切片长度为零，但是它的指针值不是 nil ，因为它确实指向了一个存在的数组，所以它不是一个 nil 切片。 要知道，一个空的切片（假设它的容量不为0）是可以扩充的，但是一个 nil 切片由于没有可以填充元素的底层数组，所以是无法扩充的。 nil 可以通过重分配数组的方式来追加元素，正如上一节所讲的。 ","date":"2021-05-05","objectID":"/slices_in_go/:10:0","tags":["Go","切片"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"Strings 这一节用于简短的介绍一下 Go 语言中在切片背景下的字符串。 字符串很简单：它是只读的字节切片，外加一点来自语言的额外的语法支持。 因为字符串是只读的，所以它们并不需要容量（你不能扩充他们），但是大多数情况下你可以把它们视为只读的字节切片。 我们可以通过索引访问单个字节： slash := \"/usr/ken\"[0] // yields the byte value '/'. 可以对字符串进行切片来获取子串： usr := \"/usr/ken\"[0:4] // yields the string \"/usr\" 当我们对字符串进行切片时，幕后发生了什么你应该已经了解了。 我们也可以用一个普通的字节切片来创建字符串： str := string(slice) 或者反过来操作： slice := []byte(usr) 字符串的底层数组对于我们来说是不可见的，除了通过字符串本身，我们无法访问到它的内容。也就是说在进行上面的转换时，必须复制数组，不过 Go 语言帮我们处理了。完成转换之后，对于字节切片底层数组的修改并不会影响对应的字符串，因为他们指向的是不同的底层数组。 这种类切片的字符串设计使得创建子字符串非常容易，我们只需要创建一个字符串头即可，由于字符串是只读的，因此子串可以和原字符串安全的共享相同的底层数组。 这篇博客更加深入的介绍了有关字符串的内容。 ","date":"2021-05-05","objectID":"/slices_in_go/:11:0","tags":["Go","切片"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"Conclusion 了解切片的工作原理有助于了解切片的实现方式。一个关键的数据结构，即切片头结构体，它与切片变量相关联，并且它描述了底层数组的一部分。当我们传递切片值时，将传递切片头结构体的副本，但它始终指向同一个底层数组。 一旦你了解了切片的工作原理，你会发现切片不仅便于使用，而且非常强大，特别是在多个内置函数的加持下。 ","date":"2021-05-05","objectID":"/slices_in_go/:12:0","tags":["Go","切片"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"More reading 除了前面提到的“Slice Tricks”，Go Slices这篇博客用图表描述了内存布局的细节。Russ Cox写的Go Data Structures这篇文章包括了对切片的讨论以及其他 Go 语言内置的数据结构。 还有很多可用的资料，但是最好的学习方法还是在coding中去使用它们。 ","date":"2021-05-05","objectID":"/slices_in_go/:13:0","tags":["Go","切片"],"title":"slice in Go","uri":"/slices_in_go/"}]