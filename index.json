[{"categories":["Go"],"content":"goè¯­è¨€çš„æ¥å£è¡¨ç¤ºä¸€ä¸ªç¡®å®šçš„æ–¹æ³•é›†ï¼Œå¹¶ä¸”æ˜¯éšå¼å®ç°çš„ï¼Œä¹Ÿå°±æ˜¯è¯´æ— éœ€åƒjavaé‚£æ ·æ˜¾å¼çš„è¯´æ˜è¯¥ç±»å®ç°äº†å“ªä¸ªæ¥å£ï¼Œåªè¦æŸä¸ªéæ¥å£ç±»å‹çš„å…·ä½“å€¼å®ç°äº†æŸä¸ªæ¥å£é‡Œçš„å…¨éƒ¨æ–¹æ³•ï¼Œå°±å¯ä»¥è¯´è¯¥å€¼å®ç°äº†æŸä¸ªæ¥å£ç±»å‹ï¼Œè¯¥æ¥å£ç±»å‹çš„å˜é‡å°±èƒ½å­˜å‚¨å®ƒã€‚ ä¸€ä¸ªå…¸å‹çš„ä¾‹å­æ˜¯io.Readerå’Œio.Writerï¼Œå³ioåŒ…ä¸­çš„Readerå’ŒWriterç±»å‹ï¼š // Reader is the interface that wraps the basic Read method. type Reader interface { Read(p []byte) (n int, err error) } // Writer is the interface that wraps the basic Write method. type Writer interface { Write(p []byte) (n int, err error) } ä»»ä½•æ­£ç¡®å®ç°äº†Read/Writeæ–¹æ³•ï¼ˆæŒ‡æ–¹æ³•çš„å‚æ•°å’Œè¿”å›å€¼è¦å¯¹åº”ï¼‰çš„ç±»å‹ï¼ŒåŒæ—¶ä¹Ÿå°±å®ç°äº†io.Reader/io.Writeræ¥å£ã€‚å¦‚æœæŸä¸ªå€¼çš„ç±»å‹å®ç°äº†Readæ–¹æ³•ï¼Œio.Readerç±»å‹çš„å˜é‡å°±èƒ½ä¿å­˜å®ƒï¼š var r io.Reader r = os.Stdin r = bufio.NewReader(r) r = new(bytes.Buffer) // and so on æ— è®ºrä¿å­˜äº†ä»€ä¹ˆå…·ä½“çš„å€¼ï¼Œrçš„ç±»å‹æ€»æ˜¯io.Readerï¼šGoæ˜¯é™æ€ç±»å‹çš„ï¼Œè€Œrçš„é™æ€ç±»å‹å°±æ˜¯io.Reader ","date":"2021-06-17","objectID":"/interface_in_go/:0:0","tags":["Go","interface"],"title":"interface in go","uri":"/interface_in_go/"},{"categories":["Go"],"content":"æ¥å£çš„ä½¿ç”¨ é¦–å…ˆå®šä¹‰æ¥å£ç±»å‹ï¼š type ReadCloser interface { Read(b []byte) (n int, err os.Error) Close() } ç„¶åå®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œéœ€è¦ä¼ å…¥ä¸€ä¸ªReadCloserç±»å‹ä½œä¸ºå‚æ•°ï¼š func ReadAndClose(r ReadCloser, buf []byte) (n int, err os.Error) { for len(buf) \u003e 0 \u0026\u0026 err == nil { var nr int nr, err = r.Read(buf) n += nr buf = buf[nr:] } r.Close() return } è¯¥å‡½æ•°ä¼šå¾ªç¯è¯»å–bufä¸­çš„æ•°æ®ç„¶åè°ƒç”¨close è°ƒç”¨è¯¥å‡½æ•°çš„ä»£ç éœ€è¦ä¼ å…¥ä¸€ä¸ªå€¼ï¼Œè¯¥å€¼çš„ç±»å‹å¿…é¡»æ­£ç¡®çš„å®ç°Readå’ŒCloseæ–¹æ³•ã€‚ä¸åŒäºPythonï¼Œå¦‚æœä½ ä¼ å…¥äº†ä¸€ä¸ªé”™è¯¯ç±»å‹çš„å€¼ï¼Œä¼šåœ¨ç¼–è¯‘æ—¶æŠ¥é”™è€Œä¸æ˜¯è¿è¡Œæ—¶ æ¥å£å¹¶ä¸æ˜¯åªèƒ½é™æ€æ£€æŸ¥ï¼Œä½ ä¹Ÿå¯ä»¥åŠ¨æ€åœ°æ£€æŸ¥ç‰¹å®šçš„æ¥å£å€¼æ˜¯å¦æœ‰ç¡®å®šçš„æ–¹æ³•ï¼š type Stringer interface { String() string } func ToString(any interface{}) string { if v, ok := any.(Stringer); ok { return v.String() } switch v := any.(type) { case int: return strconv.Itoa(v) case float: return strconv.Ftoa(v, 'g', -1) } return \"???\" } ToStringæ–¹æ³•ä¼ å…¥çš„å‚æ•°anyæ˜¯interface{}ç±»å‹ï¼Œä¹Ÿå°±æ˜¯ç©ºæ¥å£ç±»å‹ï¼Œå®ƒè¡¨ç¤ºç©ºæ–¹æ³•é›†ï¼Œå› ä¸ºä»»ä½•å€¼éƒ½æœ‰é›¶ä¸ªæˆ–å¤šä¸ªæ–¹æ³•ï¼Œå› æ­¤ä»»ä½•å€¼éƒ½æ»¡è¶³ç©ºæ¥å£ï¼Œä¹Ÿå°±æ˜¯è¯´ç©ºæ¥å£å¯ä»¥åŒ…æ‹¬ä»»ä½•å€¼ã€‚ifè¯­å¥è¡¨ç¤ºå°†anyè½¬ä¸ºStringerç±»å‹çš„å€¼æ˜¯å¦å¯è¡Œã€‚å¦‚æœå¯è¡Œï¼Œè°ƒç”¨String()æ–¹æ³•ï¼Œå¦åˆ™æ‰§è¡Œswitchè¯­å¥åˆ¤æ–­æ˜¯å¦æ˜¯å…¶ä»–ç±»å‹ã€‚è¿™ä¸ªè¿‡ç¨‹ç±»ä¼¼äºfmtåŒ…çš„æ‰§è¡Œè¿‡ç¨‹ ä¸º64ä½çš„integerç±»å‹å®ç°ä¸€ä¸ªStringer()æ–¹æ³•ï¼š type Binary uint64 func (i Binary) String() string { return strconv.Uitob64(i.Get(), 2) } func (i Binary) Get() uint64 { return uint64(i) } è¿™æ ·ä¸€ä¸ªBinaryç±»å‹çš„å€¼å°±å¯ä»¥ä½œä¸ºå‚æ•°ä¼ å…¥ToStringæ–¹æ³•ä¸­ï¼Œç„¶åå°±å¯ä»¥è°ƒç”¨Stringæ–¹æ³•å°†å…¶å€¼æ ¼å¼åŒ–ï¼Œå³ä½¿Binaryå¹¶æ²¡æœ‰æ˜¾å¼çš„å£°æ˜å®ƒå®ç°äº†Stringeræ¥å£ï¼Œç”šè‡³å†™Binaryçš„äººä¸çŸ¥é“Stringeræ¥å£çš„å­˜åœ¨ ä¸Šè¿°ä¾‹å­è¡¨æ˜å³ä½¿åœ¨ç¼–è¯‘æ—¶å®Œæˆäº†éšå¼è½¬æ¢çš„æ£€æŸ¥ï¼Œæ˜¾å¼çš„æ¥å£é—´çš„è½¬æ¢ä¼šåœ¨è¿è¡Œæ—¶æ£€æŸ¥æ–¹æ³•é›†ï¼ŒEffective Goä¸­æœ‰æ›´è¯¦ç»†çš„è§£é‡Š ","date":"2021-06-17","objectID":"/interface_in_go/:1:0","tags":["Go","interface"],"title":"interface in go","uri":"/interface_in_go/"},{"categories":["Go"],"content":"æ¥å£å€¼ ä¸€ä¸ªBinaryç±»å‹çš„å€¼æ˜¯ä¸€ä¸ª64ä½çš„Integerï¼Œå ä¸¤ä¸ªå­—é•¿ã€‚è¿™é‡Œå£°æ˜ä¸€ä¸ªå˜é‡bä¸ºä¸€ä¸ªå€¼ä¸º200çš„Binaryç±»å‹ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ä¸€ä¸ªæ¥å£å€¼ä»£è¡¨äº†äº†ä¸€å¯¹å†…å®¹ï¼šä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘å­˜å‚¨åœ¨è¯¥æ¥å£ä¸­çš„å…·ä½“çš„åº•å±‚ç±»å‹æè¿°ç¬¦ï¼Œå¦ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘è¯¥å…·ä½“ç±»å‹çš„å…·ä½“çš„å€¼ã€‚è¿™é‡Œå£°æ˜ä¸€ä¸ªå˜é‡sï¼Œsæ˜¯ä¸€ä¸ªStringeræ¥å£ç±»å‹ï¼Œå…¶å®é™…å­˜å‚¨çš„æ˜¯ä¸Šé¢å£°æ˜çš„å˜é‡bï¼š ä¸Šå›¾ä¸­çš„æŒ‡é’ˆå›¾æ ‡æ˜¯ç°è‰²çš„ï¼Œç”¨ä»¥å¼ºè°ƒå®ƒä»¬æ˜¯éšå¼çš„ï¼Œä¸ç›´æ¥æš´éœ²ç»™goç¨‹åº æ¥å£å€¼ä¸­çš„ç¬¬ä¸€ä¸ªå­—æ®µæŒ‡å‘æ¥å£è¡¨ï¼Œä¹Ÿå°±æ˜¯ä¸Šå›¾ä¸­çš„itableï¼Œitableä¸­åŒ…å«äº†å­˜å‚¨çš„åº•å±‚ç±»å‹çš„å…ƒæ•°æ®å’Œå‡½æ•°æŒ‡é’ˆçš„åˆ—è¡¨ã€‚è¿™é‡Œitableå¯¹åº”çš„æ˜¯å…·ä½“ç±»å‹ï¼Œè€Œä¸æ˜¯æ¥å£ç±»å‹ã€‚åœ¨è¿™ä¸ªä¾‹å­é‡Œé¢ï¼ŒStringerçš„itableä¿å­˜çš„æ˜¯Binaryç±»å‹ï¼Œä»¥åŠæ»¡è¶³Stringeræ¥å£çš„æ–¹æ³•Sting()ï¼ŒBinaryçš„å¦ä¸€ä¸ªæ–¹æ³•Get()å¹¶æ²¡æœ‰è¢«åŒ…å«åœ¨itableä¸­ æ¥å£å€¼ä¸­çš„ç¬¬äºŒä¸ªå­—æ®µæŒ‡å‘å®é™…çš„å€¼ï¼Œåœ¨è¿™ä¸ªä¾‹å­é‡Œé¢æ˜¯å˜é‡bçš„ä¸€ä¸ªå‰¯æœ¬ã€‚èµ‹å€¼è¯­å¥ var s Stringer = b åˆ›é€ äº†ä¸€ä¸ªbçš„å‰¯æœ¬ï¼Œè€Œä¸æ˜¯ç›´æ¥æŒ‡å‘bï¼ŒåŒæ ·çš„ï¼Œvar c uint64 = b ä¹Ÿåˆ›å»ºäº†ä¸€ä¸ªbçš„å‰¯æœ¬ï¼Œå¦‚æœbçš„å€¼å˜åŒ–äº†ï¼Œså’Œcä¼šç»´æŒåŸæ¥çš„å€¼ï¼Œè€Œä¸ä¼šå˜ä¸ºæ–°çš„å€¼ã€‚æ¥å£ä¸­ä¿å­˜çš„å€¼å¯èƒ½æ˜¯ä»»æ„å¤§å°ï¼Œä½†æ˜¯æ¥å£å®é™…ä¸Šåªæ˜¯ä¿å­˜ç›¸åº”çš„æŒ‡é’ˆï¼Œå› æ­¤ä¸Šè¿°çš„èµ‹å€¼è¯­å¥ä¼šåœ¨å †ä¸Šåˆ†é…ä¸€å—å†…å­˜æ¥è®°å½•å®é™…çš„å€¼ åœ¨ç»™æ¥å£èµ‹å€¼æ—¶ï¼Œç¼–è¯‘å™¨ä¼šæ ¹æ®itableä¸­çš„ä¿¡æ¯æ£€æŸ¥ç±»å‹æ˜¯å¦æ­£ç¡®ï¼Œå¦‚æœç±»å‹åŒ¹é…ï¼Œåˆ™ä¼šå¤åˆ¶ä¸€ä»½å‰¯æœ¬å­˜å‚¨ã€‚è°ƒç”¨æ¥å£å‡½æ•°æ—¶ï¼Œç¼–è¯‘å™¨ä¼šæ ¹æ®itableä¸­çš„å‡½æ•°æŒ‡é’ˆåˆ—è¡¨è°ƒç”¨å¯¹åº”çš„å‡½æ•°ï¼ŒåŒæ—¶ä¼ å…¥æŒ‡å‘å®é™…å€¼çš„æŒ‡é’ˆã€‚é€šå¸¸æ¥å£åœ¨è°ƒç”¨å‡½æ•°æ—¶ä¸çŸ¥é“ä¼ å…¥çš„è¿™ä¸ªæŒ‡é’ˆå­—æ®µçš„æ„ä¹‰æ˜¯ä»€ä¹ˆï¼Œä¹Ÿä¸çŸ¥é“è¿™ä¸ªæŒ‡é’ˆæŒ‡å‘ä»€ä¹ˆå€¼ï¼Œåªæ˜¯itableä¸­çš„å‡½æ•°æŒ‡é’ˆéœ€è¦è¯¥æŒ‡é’ˆå­—æ®µä½œä¸ºå‚æ•°ã€‚å› æ­¤ï¼Œåœ¨è¿™ä¸ªä¾‹å­é‡Œé¢ï¼Œå‡½æ•°æŒ‡é’ˆæ˜¯ (*Binary).String è€Œä¸æ˜¯ Binary.String ã€‚ ","date":"2021-06-17","objectID":"/interface_in_go/:2:0","tags":["Go","interface"],"title":"interface in go","uri":"/interface_in_go/"},{"categories":["Go"],"content":"ç”ŸæˆItable ç°åœ¨æˆ‘ä»¬çŸ¥é“itablesé•¿ä»€ä¹ˆæ ·äº†ï¼Œä½†æ˜¯å®ƒæ˜¯æ€ä¹ˆç”Ÿæˆçš„å‘¢ï¼Ÿç¼–è¯‘å™¨ä¸ºæ¯ä¸ªå…·ä½“ç±»å‹ï¼Œä¾‹å¦‚Binaryï¼Œintï¼Œfunc(map[int]string)ç­‰åˆ›å»ºç±»å‹æè¿°ç¬¦ï¼ŒåŒ…å«äº†å…ƒæ•°æ®ï¼Œæ–¹æ³•åˆ—è¡¨ç­‰ç­‰ä¿¡æ¯ï¼Œç„¶åä¸ºæ¯ä¸ªç»“æ„ä½“å¸¸è§ç±»ä¼¼çš„ç±»å‹æè¿°ç¬¦ï¼Œæ¥å£åœ¨è¿è¡Œæ—¶æ ¹æ®è‡ªå·±çš„æ–¹æ³•è¡¨å»æŸ¥æ‰¾å…·ä½“ç±»å‹çš„ç±»å‹æè¿°ç¬¦ä¸­å¯¹åº”çš„æ–¹æ³•åˆ—è¡¨æ¥ç”Ÿæˆitable åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼ŒStringeræ‹¥æœ‰1ä¸ªæ–¹æ³•ï¼ŒBinaryæœ‰ä¸¤ä¸ªæ–¹æ³•ã€‚å‡è®¾æ¥å£ç±»å‹æœ‰niä¸ªæ–¹æ³•ï¼Œå…·ä½“ç±»å‹æœ‰ntä¸ªæ–¹æ³•ï¼Œå¯»æ‰¾æ¯ä¸ªæ¥å£æ–¹æ³•ä¸å…·ä½“ç±»å‹ä¸­å¯¹åº”çš„æ–¹æ³•çš„æ˜ å°„çš„å¤æ‚åº¦ä¸ºO(ni*nt)ï¼Œä½†æ˜¯å¯ä»¥ä¼˜åŒ–è‡³*O(ni+nt)*çš„å¤æ‚åº¦ ","date":"2021-06-17","objectID":"/interface_in_go/:3:0","tags":["Go","interface"],"title":"interface in go","uri":"/interface_in_go/"},{"categories":["Go"],"content":"å‚è€ƒ https://research.swtch.com/ https://blog.go-zh.org/laws-of-reflection https://blog.golang.org/laws-of-reflection ","date":"2021-06-17","objectID":"/interface_in_go/:4:0","tags":["Go","interface"],"title":"interface in go","uri":"/interface_in_go/"},{"categories":["evm"],"content":"Hyperledger Burrowæ˜¯Hyperledgerä¸‹çš„ä¸€ä¸ªå­é¡¹ç›®ï¼Œå®ƒå®ç°äº†ç¬¦åˆä»¥å¤ªåŠè§„èŒƒçš„EVMï¼Œè¿™ç¯‡æ–‡ç« ä¸­å¯¹evmåŠç›¸å…³ä»£ç è¿›è¡Œäº†åˆ†æ ","date":"2021-05-23","objectID":"/burrow-evm/:0:0","tags":["evm"],"title":"Hyperledger Burrowä¸­çš„evmåŠç›¸å…³ç»„ä»¶æºç åˆ†æ","uri":"/burrow-evm/"},{"categories":["evm"],"content":"acm acmä¸­åŒ…å«äº†è´¦æˆ·ä»¥åŠè´¦æˆ·çŠ¶æ€ç›¸å…³çš„ä»£ç  è¯¥æ–‡ä»¶å¤¹çš„åç§°å¤§æ¦‚æ¥æºäºâ€œaccount managementâ€ ","date":"2021-05-23","objectID":"/burrow-evm/:1:0","tags":["evm"],"title":"Hyperledger Burrowä¸­çš„evmåŠç›¸å…³ç»„ä»¶æºç åˆ†æ","uri":"/burrow-evm/"},{"categories":["evm"],"content":"acmstate state.go state.go ä¸­å®šä¹‰äº†ä¸¤ä¸ªhashå€¼ç±»å‹ä»¥åŠå¯¹åº”çš„ç¼–ç /è§£ç æ“ä½œï¼Œè¿˜å®šä¹‰äº†å¯¹è´¦æˆ·ã€å­˜å‚¨ã€å…ƒæ•°æ®çš„è¯»/å†™/éå†æ“ä½œæ¥å£ Metadatahashï¼Œè¡¨ç¤ºå…ƒæ•°æ®çš„hashï¼Œç”¨äºå…ƒæ•°æ®å¯»å€ï¼Œä¸º256ä½çš„å­—èŠ‚æ•°ç»„ï¼›Codehashï¼Œè¡¨ç¤ºè´¦æˆ·ä¸­å­˜å‚¨çš„ä»£ç çš„hashï¼Œç”¨äºCODEHASHæŒ‡ä»¤ï¼Œä¸º256ä¸ºå­—èŠ‚æ•°ç»„ã€‚ // MetadataHash is the keccak hash for the metadata. This is to make the metadata content-addressed type MetadataHash [32]byte // CodeHash is the keccak hash for the code for an account. This is used for the EVM CODEHASH opcode, and to find the // correct Metadata for a contract type CodeHash [32]byte æœ€å¸¸ä½¿ç”¨çš„æ¥å£ä¸ºReaderWriteræ¥å£ï¼Œä¹Ÿå°±æ˜¯evmåœ¨æ‰§è¡Œæ—¶æ‰€éœ€çš„ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œå®ƒåŒ…æ‹¬äº†å¯¹äºè´¦æˆ·å’Œå­˜å‚¨çš„è¯»å†™æ“ä½œ // Read and write account and storage state type ReaderWriter interface { Reader Writer } // Read-only account and storage state type Reader interface { AccountGetter StorageGetter } type Writer interface { AccountUpdater StorageSetter } type AccountGetter interface { // Get an account by its address return nil if it does not exist (which should not be an error) GetAccount(address crypto.Address) (*acm.Account, error) } type StorageGetter interface { // Retrieve a 32-byte value stored at key for the account at address, return Zero256 if key does not exist but // error if address does not GetStorage(address crypto.Address, key binary.Word256) (value []byte, err error) } type AccountUpdater interface { // Updates the fields of updatedAccount by address, creating the account // if it does not exist UpdateAccount(updatedAccount *acm.Account) error // Remove the account at address RemoveAccount(address crypto.Address) error } type StorageSetter interface { // Store a 32-byte value at key for the account at address, setting to Zero256 removes the key SetStorage(address crypto.Address, key binary.Word256, value []byte) error } state.go ä¸­è¿˜å®šä¹‰äº†ä¸€ä¸ªå‡½æ•°ç”¨äºè·å–å…¨å±€è´¦æˆ·æƒé™ // Get global permissions from the account at GlobalPermissionsAddress func GlobalAccountPermissions(getter AccountGetter) (permission.AccountPermissions, error) { acc, err := getter.GetAccount(acm.GlobalPermissionsAddress) if err != nil { return permission.AccountPermissions{}, err } if acc == nil { return permission.AccountPermissions{}, fmt.Errorf(\"global permissions account is not defined but must be\") } return acc.Permissions, nil } å…¨å±€è´¦æˆ·æƒé™åœ°å€å®šä¹‰åœ¨account.goä¸­ï¼Œä¸ºé›¶å€¼åœ°å€ï¼Œè¯¥åœ°å€çš„æƒé™å­—æ®µåŒ…å«äº†è´¦æˆ·å…è®¸è®¾ç½®çš„å…¨éƒ¨æƒé™ state_cache.go state_cache.go å®šä¹‰äº†ç¼“å­˜çš„ç±»å‹ï¼Œå¯¹ç¼“å­˜å†…å®¹çš„æ“ä½œä»¥åŠå°†ç¼“å­˜å†…å®¹å†™å›çš„æ–¹æ³•ã€‚ type Cache struct { sync.RWMutex //è¯»å†™é” name string //ç¼“å­˜åç§° backend Reader //è¯»æ“ä½œæ¥å£ï¼ŒåŒ…æ‹¬è¯»å–è´¦æˆ·å’Œè¯»å–å­˜å‚¨ accounts map[crypto.Address]*accountInfo //å…·ä½“ç¼“å­˜çš„å†…å®¹ readonly bool //åªè¯»æ ‡å¿—ä½ } type accountInfo struct { sync.RWMutex //è¯»å†™é” account *acm.Account //è´¦æˆ· storage map[binary.Word256][]byte //è´¦æˆ·çš„å­˜å‚¨ removed bool //è´¦æˆ·æ˜¯å¦å·²ç»ç§»é™¤ updated bool //è´¦æˆ·æ˜¯å¦éœ€è¦æ›´æ–° } type CacheOption func(*Cache) *Cache //ä½¿ç”¨ç¤ºä¾‹å¦‚ReadOnly var ReadOnly CacheOption = func(cache *Cache) *Cache { cache.readonly = true return cache } Cacheå®ç°äº†ReaderWriteræ¥å£ï¼Œä½†æ˜¯æ‰€æœ‰æ–¹æ³•å‡æ˜¯å¯¹ç¼“å­˜ä¸­çš„accountInfoè¿›è¡Œæ“ä½œï¼Œæ¯ç§æ–¹æ³•éƒ½ä¼šå…ˆæ£€æŸ¥è´¦æˆ·/å­˜å‚¨æ˜¯å¦åœ¨ç¼“å­˜ä¸­ï¼Œå¦‚æœæ²¡æœ‰ï¼Œåˆ™å°†å…¶åŠ å…¥ç¼“å­˜ // Syncs changes to the backend in deterministic order. Sends storage updates before updating // the account they belong so that storage values can be taken account of in the update. func (cache *Cache) Sync(st Writer) error { if cache.readonly { // Sync is (should be) a no-op for read-only - any modifications should have been caught in respective methods return nil } cache.Lock() defer cache.Unlock() var addresses crypto.Addresses for address := range cache.accounts { addresses = append(addresses, address) } sort.Sort(addresses) for _, address := range addresses { accInfo := cache.accounts[address] accInfo.RLock() if accInfo.removed { err := st.RemoveAccount(address) if err != nil { return err } } else if accInfo.updated { // First update account in case it needs to be created err := st.UpdateAccount(accInfo.account) if err != nil { return err } // Sort keys var keys binary.Words256 for key := range accInfo.storage { keys = append(keys, key) } sort.Sort(keys) // Update account's storage for _, key := range keys { value := accInfo.storage[key] err := st.SetStorage(address, key, value) if err != nil { return err } } } accInfo.RUnlock() } return nil } CacheåŒ…å«ä¸€ä¸ªSyncæ–¹æ³•","date":"2021-05-23","objectID":"/burrow-evm/:1:1","tags":["evm"],"title":"Hyperledger Burrowä¸­çš„evmåŠç›¸å…³ç»„ä»¶æºç åˆ†æ","uri":"/burrow-evm/"},{"categories":["evm"],"content":"execution execution ä¸­åŒ…å«äº†æ‰§è¡Œç¯å¢ƒç›¸å…³ä»£ç  ","date":"2021-05-23","objectID":"/burrow-evm/:2:0","tags":["evm"],"title":"Hyperledger Burrowä¸­çš„evmåŠç›¸å…³ç»„ä»¶æºç åˆ†æ","uri":"/burrow-evm/"},{"categories":["evm"],"content":"engine account.go account.go ä¸­å®šä¹‰äº†éƒ¨ç½²åˆçº¦ä»£ç ã€éƒ¨ç½²WASMä»£ç ã€ä¿®æ”¹è´¦æˆ·çŠ¶æ€ç›¸å…³çš„å‡½æ•°ï¼Œè¿™äº›å‡½æ•°è¢«ç”¨äºcontract.goçš„æŒ‡ä»¤æ‰§è¡Œä¸­ accounts.go accounts.go ä¸­å®šä¹‰äº†è·å–è´¦æˆ·ã€åˆ›å»ºè´¦æˆ·ã€æƒé™æ£€æŸ¥ç›¸å…³çš„å‡½æ•° func EnsurePermission(callFrame *CallFrame, address crypto.Address, perm permission.PermFlag) error { hasPermission, err := HasPermission(callFrame, address, perm) if err != nil { return err } else if !hasPermission { return errors.PermissionDenied{ Address: address, Perm: perm, } } return nil } // CONTRACT: it is the duty of the contract writer to call known permissions // we do not convey if a permission is not set // (unlike in state/execution, where we guarantee HasPermission is called // on known permissions and panics else) // If the perm is not defined in the acc nor set by default in GlobalPermissions, // this function returns false. func HasPermission(st acmstate.Reader, address crypto.Address, perm permission.PermFlag) (bool, error) { acc, err := st.GetAccount(address) if err != nil { return false, err } if acc == nil { return false, fmt.Errorf(\"account %v does not exist\", address) } globalPerms, err := acmstate.GlobalAccountPermissions(st) if err != nil { return false, err } perms := acc.Permissions.Base.Compose(globalPerms.Base) value, err := perms.Get(perm) if err != nil { return false, err } return value, nil } è¿™é‡Œæƒé™æ£€æŸ¥æ˜¯é€šè¿‡è°ƒç”¨state.goä¸­çš„GlobalAccountPermissionså‡½æ•°æ¥è·å–ä½œä¸ºåŸºå‡†çš„æƒé™ï¼Œç„¶åæ£€æŸ¥è¯¥è´¦æˆ·è®¾ç½®çš„åŸºå‡†æƒé™ä¸­æ˜¯å¦åŒ…å«ç›®æ ‡æƒé™ blockchain.go blockchain.go ä¸­å®šä¹‰äº†ä¸€ä¸ªå®ç°äº†Blockchainæ¥å£çš„TestBlockChainç±»å‹ç”¨äºæµ‹è¯• call_frame.go call_frame.go ä¸­å®šä¹‰äº† CallFrame ç»“æ„ä½“ï¼Œç›¸å½“äºä¸€ä¸ªè°ƒç”¨æ ˆ type CallFrame struct { // Cache this State wraps *acmstate.Cache // Where we sync backend acmstate.ReaderWriter // In order for nested cache to inherit any options cacheOptions []acmstate.CacheOption // Depth of the call stack callStackDepth uint64 // Max call stack depth maxCallStackDepth uint64 } // Create a new CallFrame to hold state updates at a particular level in the call stack func NewCallFrame(st acmstate.ReaderWriter, cacheOptions ...acmstate.CacheOption) *CallFrame { return newCallFrame(st, 0, 0, cacheOptions...) } func newCallFrame(st acmstate.ReaderWriter, stackDepth uint64, maxCallStackDepth uint64, cacheOptions ...acmstate.CacheOption) *CallFrame { return \u0026CallFrame{ Cache: acmstate.NewCache(st, cacheOptions...), backend: st, cacheOptions: cacheOptions, callStackDepth: stackDepth, maxCallStackDepth: maxCallStackDepth, } } ... func (st *CallFrame) NewFrame(cacheOptions ...acmstate.CacheOption) (*CallFrame, error) { if st.maxCallStackDepth \u003e 0 \u0026\u0026 st.maxCallStackDepth == st.callStackDepth { return nil, errors.Codes.CallStackOverflow } return newCallFrame(st.Cache, st.callStackDepth+1, st.maxCallStackDepth, append(st.cacheOptions, cacheOptions...)...), nil } func (st *CallFrame) Sync() error { err := st.Cache.Sync(st.backend) if err != nil { return errors.AsException(err) } return nil } NewCallFrameå‡½æ•°æš´éœ²ç»™å¤–ç•Œç”¨äºåˆ›å»ºæ–°çš„CallFrameï¼Œè¯¥å‡½æ•°æ¥å—ä¸¤ä¸ªå‚æ•°ï¼šå®ç°äº†ReaderWriteræ¥å£çš„ç±»å‹å’Œä»»æ„å¤šä¸ªCacheOptionï¼Œå¹¶è°ƒç”¨å†…éƒ¨å‡½æ•°nameCallFrameæ¥åˆ›å»ºCallFrame newCallFrameä¼šæ ¹æ®ä¼ å…¥çš„å‚æ•°åˆ›å»ºä¸€ä¸ªCacheï¼Œç”¨äºç¼“å­˜è´¦æˆ·åŠå­˜å‚¨ä¿¡æ¯ ä½¿ç”¨NewFrameåˆ›å»ºæ–°çš„CallFrameæ—¶ï¼Œä¼šç»§æ‰¿å½“å‰CallFrameçš„å€¼ï¼Œå¹¶å°†å½“å‰æ ˆé«˜åº¦å€¼åŠ ä¸€ï¼Œä½¿å…¶çœ‹èµ·æ¥å°±åƒåœ¨è°ƒç”¨æ ˆä¸­å‹å…¥äº†ä¸€ä¸ªæ–°çš„è°ƒç”¨ CallFrameåŒ…å«ä¸€ä¸ªSyncæ–¹æ³•ï¼Œç”¨äºå°†ç¼“å­˜å†™å›ï¼Œå…¶å†…éƒ¨ä¼šè°ƒç”¨Cacheçš„Sync()æ–¹æ³•æ‰§è¡Œå†™å›æ“ä½œ call.go call.goä¸­å®ç°äº†ä¸€ä¸ªCallå‡½æ•°ï¼Œä¸ºæ‰€æœ‰Callable.Callæ¥å£çš„å®ç°ç±»å‹æä¾›äº†ä¸€å±‚å°è£…ï¼š // Call provides a standard wrapper for implementing Callable.Call with appropriate error handling and event firing. func Call(state State, params CallParams, execute func(State, CallParams) ([]byte, error)) ([]byte, error) { maybe := new(errors.Maybe) if params.CallType == exec.CallTypeCall || params.CallType == exec.CallTypeCode { // NOTE: Delegate and Static CallTypes do not transfer the value to the callee. maybe.PushError(Transfer(state.CallFrame, params.Caller, params.Callee, \u0026params.Value)) } output := maybe.Bytes(execute(state, params)) // fire the post call event (including exception if applicable) and make sure we return the accumulated call error maybe.PushError(FireCallEvent(state.CallFrame, maybe.Error(), state.EventSink, output, params)) return output, maybe.Error() } å…¶ä¸­ç¬¬ä¸‰ä¸ªå‚æ•°executeå°±æ˜¯å®šä¹‰äº†å…·ä½“çš„æ‰§è¡Œè¿‡ç¨‹çš„å‡½æ•°ï¼Œåœ¨burrowä¸­ï¼Œåˆçº¦è°ƒç”¨/åŸç”Ÿåˆçº¦/åŸç”Ÿå‡½æ•°/","date":"2021-05-23","objectID":"/burrow-evm/:2:1","tags":["evm"],"title":"Hyperledger Burrowä¸­çš„evmåŠç›¸å…³ç»„ä»¶æºç åˆ†æ","uri":"/burrow-evm/"},{"categories":["evm"],"content":"evm abi abi.go // Struct reflection // SpecFromStructReflect generates a FunctionSpec where the arguments and return values are // described a struct. Both args and rets should be set to the return value of reflect.TypeOf() // with the respective struct as an argument. //å¯¹ç»“æ„ä½“çš„æ¯ä¸ªå­—æ®µéƒ½æ„é€ ä¸€ä¸ªArguementç±»å‹ï¼Œç”¨Arguementåˆ‡ç‰‡æ¥è¡¨ç¤ºä¸€ä¸ªç»“æ„ä½“ func SpecFromStructReflect(fname string, args reflect.Type, rets reflect.Type) *FunctionSpec { inputs := make([]Argument, args.NumField()) outputs := make([]Argument, rets.NumField()) for i := 0; i \u003c args.NumField(); i++ { f := args.Field(i) a := typeFromReflect(f.Type) a.Name = f.Name inputs[i] = a } for i := 0; i \u003c rets.NumField(); i++ { f := rets.Field(i) a := typeFromReflect(f.Type) a.Name = f.Name outputs[i] = a } return NewFunctionSpec(fname, inputs, outputs) } func typeFromReflect(v reflect.Type) Argument { arg := Argument{Name: v.Name()} if v == reflect.TypeOf(crypto.Address{}) { arg.EVM = EVMAddress{} } else if v == reflect.TypeOf(big.Int{}) { arg.EVM = EVMInt{M: 256} } else { if v.Kind() == reflect.Array { //å¦‚æœvæ˜¯Arrayç±»å‹ï¼Œéœ€è¦è®¾ç½®ä»¥ä¸‹ä¸¤ä¸ªå­—æ®µ arg.IsArray = true arg.ArrayLength = uint64(v.Len()) //å°†vè®¾ç½®ä¸ºå…¶å­˜å‚¨çš„å…ƒç´ çš„ç±»å‹ v = v.Elem() } else if v.Kind() == reflect.Slice { arg.IsArray = true v = v.Elem() } switch v.Kind() { case reflect.Bool: arg.EVM = EVMBool{} case reflect.String: arg.EVM = EVMString{} case reflect.Uint64: arg.EVM = EVMUint{M: 64} case reflect.Int64: arg.EVM = EVMInt{M: 64} default: panic(fmt.Sprintf(\"no mapping for type %v\", v.Kind())) } } return arg } SpecFromStructReflectå‡½æ•°æ¥æ”¶ä¸¤ä¸ªreflect.Typeç±»å‹ï¼Œä»£è¡¨å‚æ•°å’Œè¿”å›å€¼çš„ç±»å‹ï¼Œå®é™…å‡ä¸ºç»“æ„ä½“ç±»å‹ï¼Œå‡½æ•°å†…éƒ¨è°ƒç”¨typeFromRelectå‡½æ•°å¯¹æ¯ä¸ªå­—æ®µè¿›è¡Œå¤„ç†ï¼Œå°†å…¶è½¬æ¢ä¸ºArguementç±»å‹ï¼Œæ ¹æ®å­—æ®µçš„å®é™…ç±»å‹è®¾ç½®EVMTypeå®ç°ç±»å‹ï¼Œå¹¶ä¿å­˜è‡³å¯¹åº”è¾“å…¥å’Œè¾“å‡ºçš„Arguementåˆ‡ç‰‡ä¸­ï¼Œç„¶åæ„é€ ä¸€ä¸ªFunctionSpecç±»å‹å¹¶è¿”å› event_spec.go // Argument is a decoded function parameter, return or event field type Argument struct { Name string EVM EVMType IsArray bool Indexed bool Hashed bool ArrayLength uint64 } Arguementç±»å‹è¢«ç”¨äºæè¿°å‡½æ•°çš„å‚æ•°/è¿”å›å€¼æˆ–è€…eventçš„è¾“å…¥ï¼Œå…¶ä¸­çš„EVMå­—æ®µä¸ºEVMTypeç±»å‹ function_spec.go // FunctionIDSize is the length of the function selector const FunctionIDSize = 4 type FunctionSpec struct { Name string FunctionID FunctionID Constant bool Inputs []Argument Outputs []Argument } type FunctionID [FunctionIDSize]byte FunctionSpecç±»å‹å®šä¹‰äº†æè¿°ä¸€ä¸ªFunctionéœ€è¦çš„å€¼ï¼ŒåŒ…æ‹¬å‡½æ•°åã€IDã€è¾“å…¥çš„å‚æ•°çš„ç±»å‹å’Œæ•°é‡ã€è¾“å‡ºçš„è¿”å›å€¼çš„ç±»å‹å’Œæ•°é‡ï¼Œå…¶ä¸­IDä¸ºå›ºå®š4å­—èŠ‚é•¿åº¦ï¼Œè¾“å…¥ä¸è¾“å‡ºå­—æ®µå‡ä¸ºArguementåˆ‡ç‰‡ packing.go packing.go ä¸­å®šä¹‰äº†ç¼–ç /è§£ç çš„å…·ä½“å‡½æ•° func Pack(argSpec []Argument, args ...interface{}) ([]byte, error) { getArg, err := argGetter(argSpec, args, false) if err != nil { return nil, err } return pack(argSpec, getArg) } func Unpack(argSpec []Argument, data []byte, args ...interface{}) error { getArg, err := argGetter(argSpec, args, true) if err != nil { return err } return unpack(argSpec, data, getArg) } func argGetter(argSpec []Argument, args []interface{}, ptr bool) (func(int) interface{}, error) { if len(args) == 1 { rv := reflect.ValueOf(args[0]) if rv.Kind() == reflect.Ptr { rv = rv.Elem() } else if ptr { return nil, fmt.Errorf(\"struct pointer required in order to set values, but got %v\", rv.Kind()) } if rv.Kind() != reflect.Struct { if len(args) == 1 { // Treat s single arg return func(i int) interface{} { return args[i] }, nil } return nil, fmt.Errorf(\"expected single argument to be struct but got %v\", rv.Kind()) } fields := rv.NumField() if fields != len(argSpec) { return nil, fmt.Errorf(\"%d arguments in struct expected, %d received\", len(argSpec), fields) } if ptr { return func(i int) interface{} { return rv.Field(i).Addr().Interface() }, nil } return func(i int) interface{} { return rv.Field(i).Interface() }, nil } if len(args) == len(argSpec) { return func(i int) interface{} { return args[i] }, nil } return nil, fmt.Errorf(\"%d arguments expected, %d received\", len(argSpec), len(args)) } Packã€Unpackæ˜¯å¯¹å¤–æš´éœ²çš„å‡½æ•° Unpackæ¥æ”¶ä¸‰ä¸ªå‚æ•°ï¼ŒargSpecä¸ºArgumentåˆ‡ç‰‡ç±»å‹ï¼Œè¡¨ç¤ºå¾…è§£ç æ•°æ®çš„ç±»å‹ï¼Œdataå­˜å‚¨å¾…è§£ç çš„æ•°æ®ï¼Œargsç”¨æ¥å­˜å‚¨è§£ç åçš„æ•°æ® argGetterè¿”å›ä¸€ä¸ªå‡½æ•° func(int) interface{} ç”¨æ¥ä¸ºargSpecä¸­çš„æ¯ä¸ªArgumentåˆ†é…ä¸€ä¸ªå‚¨è§£ç åçš„æ•°æ®çš„ç±»å‹ï¼Œä¹Ÿå°±æ˜¯argSpecå’Œargsçš„å¯¹åº”å…³ç³»ï¼Œå¦‚æœäºŒè€…é•¿åº¦ç›¸ç­‰ï¼Œå°±æ˜¯é¡ºåºå¯¹åº”ï¼Œå¦‚æœargsé•¿åº¦ä¸º1ï¼Œåˆ™åˆ¤æ–­å…¶æ˜¯å¦ä¸ºç»“æ„ä½“ç±»å‹ï¼Œè‹¥æ˜¯åˆ™æŒ‰ç…§ç»“æ„ä½“å­—æ®µé¡ºåºä¸argSpecå¯¹åº”ï¼Œå¦åˆ™æŠ¥é”™ Unpackè°ƒç”¨argGetterå‡½æ•°è·å–ç”¨äºè¿”å›ä¸argSpecä¸­æ¯ä¸ªArgumentå¯¹åº”çš„ç±»å‹","date":"2021-05-23","objectID":"/burrow-evm/:2:2","tags":["evm"],"title":"Hyperledger Burrowä¸­çš„evmåŠç›¸å…³ç»„ä»¶æºç åˆ†æ","uri":"/burrow-evm/"},{"categories":["evm"],"content":"native native ä¸åŸç”Ÿåˆçº¦æœ‰å…³ï¼Œè¿™é‡Œçš„åŸç”Ÿåˆçº¦(native contracts)çš„åŠŸèƒ½ç±»ä¼¼äºä»¥å¤ªåŠevmä¸­é¢„ç¼–è¯‘å¥½çš„åˆçº¦ï¼Œé»˜è®¤åŒ…æ‹¬å¯¹äºè´¦æˆ·æƒé™çš„æ“ä½œå’ŒåŠ å¯†æ“ä½œ contract.go contract.go ä¸­è§„å®šäº†åŸç”Ÿåˆçº¦å£°æ˜å‡½æ•°çš„çš„è§„èŒƒï¼Œå‡½æ•°å¿…é¡»å£°æ˜ä¸ºä»¥ä¸‹å½¢å¼ï¼š func unsetBase(context Context, args unsetBaseArgs) (unsetBaseRets, error) {} å¿…é¡»æœ‰ä¸€ä¸ªæˆ–ä¸¤ä¸ªå‚æ•°ä»¥åŠä¸¤ä¸ªè¿”å›å€¼ï¼Œç¬¬ä¸€ä¸ªå‚æ•°å¿…é¡»æ˜¯ Context ç±»å‹ï¼š // Context is the first argument to any native function. This struct carries // all the context an native needs to access e.g. state in burrow. type Context struct { State engine.State engine.CallParams // TODO: this allows us to call back to EVM contracts if we wish - make use of it somewhere... externals engine.Dispatcher Logger *logging.Logger } ç¬¬äºŒä¸ªå‚æ•°ä»¥åŠç¬¬ä¸€ä¸ªè¿”å›å€¼å¿…é¡»æ˜¯ç»“æ„ä½“ç±»å‹ï¼Œä¸solidityå‡½æ•°ä¸­çš„å‚æ•°ä¸è¿”å›å€¼ä¸€ä¸€å¯¹åº”ï¼Œç¬¬äºŒä¸ªè¿”å›å€¼å¿…é¡»æ˜¯errorç±»å‹ // Contract is metadata for native contract. Acts as a call target // from the EVM. Can be used to generate bindings in a smart contract languages. type Contract struct { // Comment describing purpose of native contract and reason for assembling // the particular functions Comment string // Name of the native contract Name string functionsByID map[abi.FunctionID]*Function functions []*Function address crypto.Address logger *logging.Logger } var _ engine.Native = \u0026Contract{} Contractç»“æ„ä½“ç±»å‹å®ç°äº†engine.Nativeæ¥å£ï¼ŒåŒ…å«ä¸€ä¸ªFunctionåˆ—è¡¨ï¼Œå®é™…æ‰§è¡Œå‡ç”±Functionè¿›è¡Œï¼ŒContractå¯¹Functionè¿›è¡Œäº†ä¸€å±‚åŒ…è£… // Dispatch is designed to be called from the EVM once a native contract // has been selected. func (c *Contract) Call(state engine.State, params engine.CallParams) (output []byte, err error) { if len(params.Input) \u003c abi.FunctionIDSize { return nil, errors.Errorf(errors.Codes.NativeFunction, \"Burrow Native dispatch requires a 4-byte function identifier but arguments are only %v bytes long\", len(params.Input)) } var id abi.FunctionID copy(id[:], params.Input) function, err := c.FunctionByID(id) if err != nil { return nil, err } params.Input = params.Input[abi.FunctionIDSize:] return function.Call(state, params) } // Get function by calling identifier FunctionSelector func (c *Contract) FunctionByID(id abi.FunctionID) (*Function, errors.CodedError) { f, ok := c.functionsByID[id] if !ok { return nil, errors.Errorf(errors.Codes.NativeFunction, \"unknown native function with ID %x\", id) } return f, nil } Contractç±»å‹å®ç°äº†Callableæ¥å£ï¼Œå…¶Callå‡½æ•°å†…éƒ¨æ ¹æ®paramä¸­çš„Inputå­—æ®µè·å–FunctionIDå¹¶è·å–ç›¸åº”çš„Functionï¼Œç„¶åè°ƒç”¨Functionä¸­çš„Callå‡½æ•°æ‰§è¡Œ function.go // Function is metadata for native functions. Act as call targets // for the EVM when collected into an Contract. Can be used to generate // bindings in a smart contract languages. type Function struct { // Comment describing function's purpose, parameters, and return value Comment string // Permissions required to call function PermFlag permission.PermFlag // Whether this function writes to state Pure bool // Native function to which calls will be dispatched when a containing F interface{} // Following fields are for only for memoization // The name of the contract to which this function belongs (if any) contractName string // Function name (used to form signature) name string // The abi abi *abi.FunctionSpec // Address of containing contract address crypto.Address externals engine.Dispatcher logger *logging.Logger } var _ engine.Native = \u0026Function{} Functionç±»å‹ä¹Ÿå®ç°äº†engine.Nativeæ¥å£ï¼Œå…¶ä¸­çš„Få­—æ®µå³ä¸ºnative functionï¼Œä¹Ÿå°±æ˜¯ç”±goè¯­è¨€å®ç°çš„å‡½æ•° // Created a new function mounted directly at address (i.e. no Solidity contract or function selection) func NewFunction(comment string, address crypto.Address, permFlag permission.PermFlag, f interface{}) (*Function, error) { function := \u0026Function{ Comment: comment, PermFlag: permFlag, F: f, } err := function.init(address) if err != nil { return nil, err } return function, nil } func (f *Function) init(address crypto.Address) error { // Get name of function t := reflect.TypeOf(f.F) v := reflect.ValueOf(f.F) // v.String() for functions returns the empty string fullyQualifiedName := runtime.FuncForPC(v.Pointer()).Name() a := strings.Split(fullyQualifiedName, \".\") f.name = a[len(a)-1] if t.NumIn() != 1 \u0026\u0026 t.NumIn() != 2 { return fmt.Errorf(\"native function %s must have a one or two arguments\", fu","date":"2021-05-23","objectID":"/burrow-evm/:2:3","tags":["evm"],"title":"Hyperledger Burrowä¸­çš„evmåŠç›¸å…³ç»„ä»¶æºç åˆ†æ","uri":"/burrow-evm/"},{"categories":["evm"],"content":"å‚è€ƒé“¾æ¥ Golangçš„åå°„reflectæ·±å…¥ç†è§£å’Œç¤ºä¾‹ åå°„ä¸‰æ³•åˆ™ ","date":"2021-05-23","objectID":"/burrow-evm/:3:0","tags":["evm"],"title":"Hyperledger Burrowä¸­çš„evmåŠç›¸å…³ç»„ä»¶æºç åˆ†æ","uri":"/burrow-evm/"},{"categories":["Go"],"content":"æœ¬æ–‡ç¿»è¯‘è‡ªhttps://blog.golang.org/slices","date":"2021-05-05","objectID":"/slices_in_go/","tags":["Go","åˆ‡ç‰‡"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"æ³¨æ„ æœ¬æ–‡ç¿»è¯‘è‡ªhttps://blog.golang.org/slices è¿‡ç¨‹å¼ç¼–ç¨‹è¯­è¨€æœ€å¸¸è§çš„ç‰¹æ€§ä¹‹ä¸€ä¾¿æ˜¯æ•°ç»„çš„æ¦‚å¿µã€‚æ•°ç»„çœ‹èµ·æ¥å¾ˆç®€å•ï¼Œä½†æ˜¯å½“æŠŠå®ƒåŠ è¿›ä¸€é—¨è¯­è¨€é‡Œæ—¶ï¼Œéœ€è¦è€ƒè™‘å¾ˆå¤šé—®é¢˜ï¼Œä¾‹å¦‚ï¼š å›ºå®šå¤§å° or å¯å˜å¤§å°ï¼Ÿ æ•°ç»„çš„å¤§å°è¦ä½œä¸ºæ•°ç»„ç±»å‹çš„ä¸€éƒ¨åˆ†å—ï¼Ÿ å¤šç»´æ•°ç»„çœ‹èµ·æ¥æ˜¯ä»€ä¹ˆæ ·çš„ï¼Ÿ ç©ºæ•°ç»„æœ‰æ„ä¹‰å—ï¼Ÿ â€¦ æ•°ç»„æ˜¯è¯­è¨€çš„ä¸€ä¸ªç‰¹æ€§è¿˜æ˜¯å…¶è®¾è®¡çš„å…³é”®éƒ¨åˆ†å°†å–å†³äºè¿™äº›é—®é¢˜çš„ç­”æ¡ˆã€‚ åœ¨goçš„æ—©æœŸå¼€å‘è¿‡ç¨‹ä¸­ï¼ŒèŠ±äº†ä¸€å¹´çš„æ—¶é—´æ¥å†³å®šè¿™äº›é—®é¢˜çš„ç­”æ¡ˆã€‚å…¶ä¸­å…³é”®çš„ä¸€æ­¥ä¾¿æ˜¯å¼•å…¥äº†åˆ‡ç‰‡ï¼Œå®ƒæ„å»ºåœ¨å›ºå®šå¤§å°çš„æ•°ç»„ä¸Šï¼Œæä¾›äº†çµæ´»ã€å¯æ‰©å±•çš„æ•°æ®ç»“æ„ã€‚ç„¶è€Œï¼Œç›´åˆ°ä»Šå¤©ï¼Œå—åˆ°æ¥è‡ªäºå…¶ä»–ç¼–ç¨‹è¯­è¨€çš„ç»éªŒçš„å½±å“ï¼Œåˆšæ¥è§¦goçš„ç¨‹åºå‘˜å¾€å¾€ä¼šæ‰è¿›åˆ‡ç‰‡çš„å·¥ä½œæ–¹å¼è¿™ä¸ªå¤§å‘é‡Œã€‚ è¿™ç¯‡æ–‡ç« å°†ä¼šè§£é‡Š slice ä»¥åŠå†…ç½®å‡½æ•° append æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Œä»¥åŠè¿™æ ·è®¾è®¡çš„åŸå› ã€‚ ","date":"2021-05-05","objectID":"/slices_in_go/:0:0","tags":["Go","åˆ‡ç‰‡"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"Arrays æ•°ç»„æ˜¯goè¯­è¨€ä¸­ä¸€ä¸ªé‡è¦çš„æ„å»ºæ¨¡å—ï¼Œä½†æ˜¯å¦‚å»ºç­‘ç‰©çš„åœ°åŸºä¸€æ ·ï¼Œå®ƒé€šå¸¸éšè—åœ¨æ›´å¤šçš„å¯è§ç»„ä»¶ä¹‹ä¸‹ã€‚åœ¨è®¨è®ºåˆ‡ç‰‡çš„å…¶ä»–æ›´æœ‰è¶£ï¼Œæ›´å¼ºå¤§ï¼Œæ›´çªå‡ºçš„æ¦‚å¿µä¹‹å‰ï¼Œæˆ‘ä»¬å¿…é¡»å…ˆç®€è¦çš„è®¨è®ºä¸€ä¸‹æ•°ç»„ã€‚ æ•°ç»„åœ¨goè¯­è¨€ä¸­å¹¶ä¸å¸¸è§ï¼Œå› ä¸ºæ•°ç»„çš„å¤§å°æ˜¯å®ƒçš„ç±»å‹çš„ä¸€éƒ¨åˆ†ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬åœ¨å£°æ˜ä¸€ä¸ªæ•°ç»„æ—¶ï¼Œå¿…é¡»æŒ‡å®šå®ƒçš„å¤§å°ï¼Œè¿™é™åˆ¶äº†æ•°ç»„çš„è¡¨è¾¾èƒ½åŠ›ã€‚ var buffer [256]byte ä¸Šé¢çš„è¡¨è¾¾å¼å£°æ˜äº†ä¸€ä¸ªå˜é‡ buffer ï¼Œå®ƒåŒ…å«256ä¸ªå­—èŠ‚ã€‚ buffer çš„ç±»å‹å£°æ˜åŒ…å«äº†å®ƒçš„å¤§å°ï¼Œ[256]byteã€‚è€Œä¸€ä¸ªåŒ…å«512ä¸ªå­—èŠ‚çš„æ•°ç»„å˜é‡ç±»å‹æ˜¯[512]byteã€‚ åŒ…å«åœ¨ä¸€ä¸ªæ•°ç»„ä¸­çš„æ•°æ®åœ¨å†…å­˜ä¸­çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„ï¼š buffer: byte byte byte ...... byte byte byte æˆ‘ä»¬å¯ä»¥é€šè¿‡ç´¢å¼•æ¥è®¿é—® buffer ä¸­çš„å…ƒç´ ï¼Œä¾‹å¦‚ buffer[0] ï¼Œ buffer[1] ï¼Œç›´åˆ° buffer[255] ã€‚è¶Šç•Œè®¿é—®bufferå°†å¯¼è‡´ç¨‹åºå´©æºƒã€‚ å†…ç½®å‡½æ•° len() å¯ä»¥è¿”å›æ•°ç»„æˆ–è€…åˆ‡ç‰‡æˆ–è€…å…¶ä»–æŸäº›æ•°æ®ç±»å‹ä¸­åŒ…å«çš„å…ƒç´ çš„æ•°é‡ï¼Œ len(buffer) è¿”å›å›ºå®šå€¼256 æ•°ç»„æœ‰å®ƒè‡ªå·±çš„ç”¨å¤„ï¼Œæ¯”å¦‚æ•°ç»„å¾ˆå¥½çš„è¡¨ç¤ºäº†è½¬æ¢çŸ©é˜µï¼Œä½†æ˜¯åœ¨goè¯­è¨€ä¸­ä»–ä»¬æ›´å¤šçš„è¢«ç”¨æ¥ä¸ºåˆ‡ç‰‡ä¿ç•™å­˜å‚¨ç©ºé—´ ","date":"2021-05-05","objectID":"/slices_in_go/:1:0","tags":["Go","åˆ‡ç‰‡"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"Slices: The slice header æƒ³è¦æ›´å¥½çš„ä½¿ç”¨åˆ‡ç‰‡ï¼Œæˆ‘ä»¬å¿…é¡»æ˜ç™½åˆ‡ç‰‡æ˜¯ä»€ä¹ˆä»¥åŠåˆ‡ç‰‡å¯ä»¥åšä»€ä¹ˆ åˆ‡ç‰‡æ˜¯ä¸€ç§æ•°æ®ç»“æ„ï¼Œå®ƒæè¿°äº†ä¸€ä¸ªæ•°ç»„ä¸­çš„ä¸€æ®µè¿ç»­çš„æ•°æ®ï¼Œæ•°ç»„ä¸åˆ‡ç‰‡å¹¶ä¸å ç”¨åŒä¸€å—å­˜å‚¨ç©ºé—´ã€‚ä¸€ä¸ªåˆ‡ç‰‡å¹¶ä¸æ˜¯ä¸€ä¸ªæ•°ç»„ã€‚åˆ‡ç‰‡æè¿°äº†æ•°ç»„çš„ä¸€ä¸ªç‰‡æ®µã€‚ ç»§ç»­ä½¿ç”¨ä¸Šä¸€èŠ‚ä¸­çš„æ•°ç»„å˜é‡ buffer ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡åˆ‡åˆ†ï¼ˆslicingï¼‰è¿™ä¸ªæ•°ç»„æ¥åˆ›é€ ä¸€ä¸ªæè¿° buffer ä¸­çš„ç¬¬100-150ä¸ªå…ƒç´ ï¼ˆä¸åŒ…æ‹¬ç¬¬150ä¸ªå…ƒç´ ï¼‰çš„åˆ‡ç‰‡ï¼š var slice []byte = buffer[100:150] å˜é‡ slice çš„ç±»å‹ä¸º []byte ï¼Œè¯»ä½œ\"slice of bytes\"ã€‚ slice é€šè¿‡åˆ‡åˆ†æ•°ç»„ buffer çš„ç¬¬100åˆ°ç¬¬150ä¸ªå…ƒç´ æ¥å®Œæˆåˆå§‹åŒ–ã€‚æ›´å¸¸ç”¨çš„è¯­æ³•æ˜¯å»æ‰ç±»å‹éƒ¨åˆ†ï¼Œæ ¹æ®åˆå§‹åŒ–è¡¨è¾¾å¼è®¾ç½®ç±»å‹ï¼š var slice = buffer[100:150] åœ¨å‡½æ•°å†…éƒ¨ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨çŸ­å˜é‡å£°æ˜ï¼š slice := buffer[100:150] æ³¨æ„åªèƒ½åœ¨å‡½æ•°å†…éƒ¨ä½¿ç”¨çŸ­å˜é‡å£°æ˜ï¼Œå› ä¸ºå‡½æ•°å¤–çš„æ¯æ¡è¯­å¥éƒ½å¿…é¡»ä»¥å…³é”®å­—å¼€å§‹ï¼ˆvarï¼Œfuncç­‰ï¼‰ã€‚ ç°åœ¨å¯ä»¥æŠŠåˆ‡ç‰‡çœ‹ä½œä¸€ä¸ªæ‹¥æœ‰ä¸¤ä¸ªå…ƒç´ çš„æ•°æ®ç»“æ„ï¼šé•¿åº¦ä»¥åŠæŒ‡å‘æ•°ç»„ä¸­æŸä¸ªå…ƒç´ çš„æŒ‡é’ˆã€‚å¯ä»¥æŠŠåˆ‡ç‰‡æƒ³è±¡æˆè¿™æ ·çš„ä¸€ä¸ªç»“æ„ä½“ï¼š type sliceHeader struct { Length int ZerothElement *byte } slice := sliceHeader{ Length: 50, ZerothElement: \u0026buffer[100], } å½“ç„¶ï¼Œè¿™åªæ˜¯ä¸€ä¸ªä¸ºäº†ä¾¿äºç†è§£åšå‡ºçš„å‡è®¾ç¤ºä¾‹ã€‚å°½ç®¡ä¸Šé¢è¿™æ®µä»£ç è¡¨æ˜ sliceHeader ç±»å‹å¯¹ç¨‹åºçŒ¿æ˜¯ä¸å¯è§çš„ï¼Œå¹¶ä¸”æŒ‡é’ˆçš„ç±»å‹å–å†³äºå®ƒæ‰€æŒ‡å‘çš„å…ƒç´ çš„ç±»å‹ï¼Œä½†æ˜¯è¿™ç»™äº†æˆ‘ä»¬å…³äºåˆ‡ç‰‡æœºåˆ¶çš„å¤§ä½“æ€è·¯ã€‚ ç›®å‰ä¸ºæ­¢æˆ‘ä»¬å·²ç»åœ¨æ•°ç»„ä¸Šè¿›è¡Œäº†åˆ‡ç‰‡æ“ä½œï¼Œä½†æ˜¯æˆ‘ä»¬è¿˜å¯ä»¥åœ¨åˆ‡ç‰‡ä¸Šè¿›è¡Œåˆ‡ç‰‡æ“ä½œï¼Œå°±åƒè¿™æ ·ï¼š slice2 := slice[5:10] å°±åƒä¹‹å‰çš„åˆ‡ç‰‡æ“ä½œä¸€æ ·ï¼Œä¸Šé¢çš„è¯­å¥åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„åˆ‡ç‰‡ï¼Œ slice2 åŒ…æ‹¬äº† slice ä¸­çš„ç¬¬5-9ï¼ˆä¸å«ï¼‰ä¸ªå…ƒç´ ï¼Œä¹Ÿå°±æ˜¯æ•°ç»„ buffer ä¸­çš„ç¬¬105-109ï¼ˆä¸å«ï¼‰ä¸ªå…ƒç´ ã€‚ slice2 åº•å±‚çš„ sliceHeader çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„ï¼š slice2 := sliceHeader{ Length: 5, ZerothElement: \u0026buffer[105], } æ³¨æ„æ­¤æ—¶ slice2 çš„ sliceHeader ä»ç„¶æŒ‡å‘ç›¸åŒçš„åº•å±‚æ•°ç»„ï¼Œä¹Ÿå°±æ˜¯ buffer ã€‚ æˆ‘ä»¬ä¹Ÿå¯ä»¥é‡åˆ‡ç‰‡ï¼ˆresliceï¼‰ï¼Œä¹Ÿå°±æ˜¯å¯¹ä¸€ä¸ªåˆ‡ç‰‡è¿›è¡Œåˆ‡ç‰‡æ“ä½œï¼Œå¹¶å°†ç»“æœå­˜å‚¨åœ¨åŸå§‹çš„åˆ‡ç‰‡ç»“æ„ä¸­ï¼š slice = slice[5:10] æ­¤æ—¶ slice çš„ sliceHeader å’Œä¸Šé¢çš„ slice2 çš„ sliceHeader çœ‹èµ·æ¥æ˜¯ä¸€æ ·çš„ã€‚é‡åˆ‡ç‰‡æ“ä½œåº”ç”¨çš„æ›´å¤šï¼Œä¾‹å¦‚æˆªæ–­ä¸€ä¸ªåˆ‡ç‰‡ã€‚ä¸‹é¢è¿™æ¡è¯­å¥åˆ é™¤äº†åˆ‡ç‰‡çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªå…ƒç´ ï¼š slice = slice[1:len(slice)-1] ä½ å¯èƒ½ç»å¸¸ä¼šå¬åˆ°è€æ‰‹ç¨‹åºçŒ¿è°ˆè®ºå…³äºâ€œåˆ‡ç‰‡å¤´â€çš„é—®é¢˜ï¼Œå› ä¸ºé‚£ç¡®å®æ˜¯å­˜å‚¨åœ¨åˆ‡ç‰‡å˜é‡ä¸­çš„å†…å®¹ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œä¸€ä¸ªåˆ‡ç‰‡å®é™…ä¸Šå°±æ˜¯ä¸Šé¢æ‰€æè¿°çš„ä¸€ä¸ªåˆ‡ç‰‡å¤´ç»“æ„ä½“ã€‚ä¾‹å¦‚ï¼Œå½“ä½ è°ƒç”¨ä¸€ä¸ªä»¥åˆ‡ç‰‡ä½œä¸ºå‚æ•°çš„å‡½æ•°æ—¶ï¼Œæ¯”å¦‚bytes.IndexRuneï¼Œå°±ä¼šç»™è¿™ä¸ªå‡½æ•°ä¼ é€’ä¸€ä¸ªåˆ‡ç‰‡å¤´ç»“æ„ä½“ã€‚åœ¨ä¸‹é¢è¿™æ¡è¯­å¥ä¸­ï¼Œ slashPos := bytes.IndexRune(slice, '/') ä¼ ç»™ IndexRune çš„å‚æ•° slice ï¼Œå…¶å®æ˜¯ä¸€ä¸ªåˆ‡ç‰‡å¤´ç»“æ„ä½“ åˆ‡ç‰‡å¤´ç»“æ„ä½“ä¸­è¿˜æœ‰ä¸€ä¸ªå…ƒç´ ï¼Œæˆ‘ä»¬å°†ä¼šåœ¨ä¸‹é¢è®¨è®ºï¼Œä½†æ˜¯é¦–å…ˆæˆ‘ä»¬å…ˆæ¥çœ‹ä¸€ä¸‹å½“æˆ‘ä»¬ä½¿ç”¨åˆ‡ç‰‡æ—¶ï¼Œåˆ‡ç‰‡å¤´çš„å­˜åœ¨æ„å‘³ç€ä»€ä¹ˆã€‚ ","date":"2021-05-05","objectID":"/slices_in_go/:2:0","tags":["Go","åˆ‡ç‰‡"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"Passing slices to functions å³ä½¿åˆ‡ç‰‡åŒ…å«ä¸€ä¸ªæŒ‡é’ˆï¼Œåˆ‡ç‰‡æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªå€¼ï¼Œç†è§£è¿™ç‚¹å¾ˆé‡è¦ã€‚å®é™…ä¸Šï¼Œå®ƒæ˜¯ä¸€ä¸ªç»“æ„ä½“å€¼ï¼ŒåŒ…å«ä¸€ä¸ªæŒ‡é’ˆå’Œä¸€ä¸ªé•¿åº¦å€¼ã€‚å®ƒä¸æ˜¯ä¸€ä¸ªæŒ‡å‘ç»“æ„ä½“çš„æŒ‡é’ˆã€‚ ğŸ‘†ä¸Šé¢è¿™ç‚¹å¾ˆé‡è¦ğŸ‘† ä¸Šä¸€ä¸ªä¾‹å­ä¸­å½“æˆ‘ä»¬è°ƒç”¨ IndexRune æ—¶ï¼Œå®ƒå®é™…ä¸Šæ¥æ”¶çš„æ˜¯ä¸€ä¸ªåˆ‡ç‰‡å¤´ç»“æ„ä½“çš„å‰¯æœ¬ã€‚è¿™ç§è¡Œä¸ºæœ‰å¾ˆé‡å¤§çš„å½±å“ã€‚ è€ƒè™‘è¿™æ ·ä¸€ä¸ªç®€å•çš„å‡½æ•°ï¼š func AddOneToEachElement(slice []byte) { for i := range slice { slice[i]++ } } å°±åƒä»–çš„å‡½æ•°åä¸€æ ·ï¼Œè¿™ä¸ªå‡½æ•°ä¼šéå†æ•´ä¸ªåˆ‡ç‰‡ï¼Œå¹¶å°†åˆ‡ç‰‡ä¸­çš„æ¯ä¸ªå…ƒç´ åŠ ä¸€ã€‚ func main() { slice := buffer[10:20] for i := 0; i \u003c len(slice); i++ { slice[i] = byte(i) } fmt.Println(\"before\", slice) AddOneToEachElement(slice) fmt.Println(\"after\", slice) } è¿è¡Œç»“æœä¸ºï¼š before [0 1 2 3 4 5 6 7 8 9] after [1 2 3 4 5 6 7 8 9 10] å°½ç®¡åˆ‡ç‰‡æ˜¯ä»¥åˆ‡ç‰‡å¤´ç»“æ„ä½“å€¼ä¼ é€’çš„æ–¹å¼ä¼ å…¥çš„ï¼Œä½†æ˜¯åˆ‡ç‰‡å¤´ç»“æ„ä½“åŒ…å«äº†ä¸€ä¸ªæŒ‡å‘åº•å±‚æ•°ç»„çš„æŒ‡é’ˆï¼Œæ‰€ä»¥ä¸ç®¡æ˜¯åŸå§‹çš„åˆ‡ç‰‡è¿˜æ˜¯ä½œä¸ºå‚æ•°ä¼ é€’çš„åˆ‡ç‰‡å‰¯æœ¬éƒ½åŒ…å«äº†æŒ‡å‘ç›¸åŒçš„åº•å±‚æ•°ç»„çš„æŒ‡é’ˆã€‚å› æ­¤ï¼Œå½“ä¸Šé¢çš„å‡½æ•°è¿”å›æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡åŸå§‹åˆ‡ç‰‡è§‚å¯Ÿåˆ°å…ƒç´ çš„æ”¹åŠ¨ã€‚ ä¸‹é¢è¿™ä¸ªä¾‹å­å±•ç¤ºäº†ä¼ é€’ç»™å‡½æ•°çš„å‚æ•°æ˜¯å‰¯æœ¬ï¼š func SubtractOneFromLength(slice []byte) []byte { slice = slice[0 : len(slice)-1] return slice } func main() { fmt.Println(\"Before: len(slice) =\", len(slice)) newSlice := SubtractOneFromLength(slice) fmt.Println(\"After: len(slice) =\", len(slice)) fmt.Println(\"After: len(newSlice) =\", len(newSlice)) } Before: len(slice) = 50 After: len(slice) = 50 After: len(newSlice) = 49 æˆ‘ä»¬å¯ä»¥çœ‹åˆ°å½“åˆ‡ç‰‡ä½œä¸ºå‚æ•°ä¼ å…¥æ—¶ï¼Œå‡½æ•°å¯ä»¥ä¿®æ”¹å®ƒåŒ…å«çš„å†…å®¹ï¼Œä¹Ÿå°±æ˜¯å®ƒæŒ‡å‘çš„åº•å±‚æ•°ç»„ä¸­çš„å€¼ï¼Œä½†æ˜¯æ— æ³•ä¿®æ”¹å®ƒçš„åˆ‡ç‰‡å¤´ç»“æ„ä½“ä¸­å…ƒç´ çš„å€¼ã€‚å­˜å‚¨åœ¨ slice ä¸­çš„é•¿åº¦å€¼å¹¶æ²¡æœ‰è¢«ä¿®æ”¹ï¼Œä¸Šé¢çš„å‡½æ•°åªæ˜¯ä¿®æ”¹äº†ä¼ å…¥çš„åˆ‡ç‰‡å¤´ç»“æ„ä½“çš„å‰¯æœ¬ï¼Œè€Œä¸æ˜¯å…¶æœ¬ä½“ã€‚è¿™æ ·å¦‚æœæˆ‘ä»¬æƒ³å†™ä¸€ä¸ªå‡½æ•°ä¿®æ”¹åˆ‡ç‰‡å¤´çš„è¯ï¼Œæˆ‘ä»¬å°±éœ€è¦å°†ä¿®æ”¹åçš„å‰¯æœ¬ä½œä¸ºç»“æœè¿”å›ã€‚åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œ slice å¹¶æ²¡æœ‰æ”¹å˜ï¼Œä½†æ˜¯è¿”å›å€¼ newSlice çš„é•¿åº¦è¢«ä¿®æ”¹äº†ã€‚ ","date":"2021-05-05","objectID":"/slices_in_go/:3:0","tags":["Go","åˆ‡ç‰‡"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"Pointers to slices: Method receivers å¦ä¸€ç§åœ¨å‡½æ•°ä¸­ä¿®æ”¹åˆ‡ç‰‡å¤´çš„æ–¹æ³•æ˜¯å°†åˆ‡ç‰‡çš„æŒ‡é’ˆä½œä¸ºå‚æ•°ä¼ å…¥ã€‚ä¸‹é¢æ˜¯ä¸Šä¸€ä¸ªä¾‹å­çš„å˜ä½“ï¼š func PtrSubtractOneFromLength(slicePtr *[]byte) { slice := *slicePtr *slicePtr = slice[0 : len(slice)-1] } func main() { fmt.Println(\"Before: len(slice) =\", len(slice)) PtrSubtractOneFromLength(\u0026slice) fmt.Println(\"After: len(slice) =\", len(slice)) } å®ƒçš„è¿è¡Œç»“æœä¸ºï¼š Before: len(slice) = 50 After: len(slice) = 49 è¿™ä¸ªä¾‹å­çœ‹èµ·æ¥å¾ˆéº»çƒ¦ï¼Œéœ€è¦å¤„ç†é—´æ¥å¼•ç”¨ï¼ˆä¾‹å­é‡Œé¢å¼•å…¥äº†ä¸€ä¸ªä¸´æ—¶å˜é‡æ¥å¸®åŠ©å¤„ç†ï¼‰ï¼Œä½†æ˜¯æœ‰ä¸€ç§å¸¸è§çš„æƒ…å†µä¸‹ä½ å¯ä»¥çœ‹åˆ°åˆ‡ç‰‡æŒ‡é’ˆï¼Œå³ï¼Œé€šå¸¸ä½¿ç”¨æŒ‡é’ˆä½œä¸ºä¿®æ”¹åˆ‡ç‰‡çš„æ–¹æ³•çš„æ¥æ”¶è€…ã€‚ æˆ‘ä»¬å‡è®¾ä¸€ä¸ªåˆ‡ç‰‡ï¼Œè¿™ä¸ªåˆ‡ç‰‡æ‹¥æœ‰ä¸€ä¸ªåœ¨æœ€åä¸€ä¸ªæ–œæ å¤„æˆªæ–­å®ƒçš„æ–¹æ³•ã€‚æˆ‘ä»¬å¯ä»¥è¿™æ ·å†™ï¼š type path []byte func (p *path) TruncateAtFinalSlash() { i := bytes.LastIndex(*p, []byte(\"/\")) if i \u003e= 0 { *p = (*p)[0:i] } } func main() { pathName := path(\"/usr/bin/tso\") // Conversion from string to path. pathName.TruncateAtFinalSlash() fmt.Printf(\"%s\\n\", pathName) } å…¶ç»“æœä¸ºï¼š /usr/bin å¦‚æœæˆ‘ä»¬å°†è¿™ä¸ªä¾‹å­é‡Œçš„æ¥æ”¶è€…ç±»å‹ç”±æŒ‡é’ˆæ”¹ä¸ºå€¼å‘¢ï¼Ÿ type path []byte func (p path) TruncateAtFinalSlash() { i := bytes.LastIndex(p, []byte(\"/\")) if i \u003e= 0 { p = (p)[0:i] } } func main() { pathName := path(\"/usr/bin/tso\") // Conversion from string to path. pathName.TruncateAtFinalSlash() fmt.Printf(\"%s\\n\", pathName) } æ­¤æ—¶è¿è¡Œç»“æœä¸ºï¼š /usr/bin/tso æ–¹æ³•æ˜¯ä¸€ç±»å¸¦æœ‰ç‰¹æ®Šçš„æ¥æ”¶è€…å‚æ•°çš„å‡½æ•°ï¼Œæ¥æ”¶è€…ä¹Ÿæ˜¯ä¸ªå‚æ•°ï¼Œå› æ­¤ï¼Œå¦‚æœä½¿ç”¨å€¼æ¥æ”¶è€…ï¼Œæ–¹æ³•ä¼šå¯¹åŸå§‹å€¼çš„å‰¯æœ¬è¿›è¡Œæ“ä½œã€‚ ä½†æ˜¯ï¼Œå½“æ¥æ”¶è€…æ˜¯åˆ‡ç‰‡ç±»å‹æ—¶ï¼Œé‚£ä¹ˆä¸ç®¡æ˜¯ä½¿ç”¨å€¼æ¥æ”¶è€…è¿˜æ˜¯æŒ‡é’ˆæ¥æ”¶è€…ï¼Œæˆ‘ä»¬éƒ½å¯ä»¥å¯¹åº•å±‚æ•°ç»„è¿›è¡Œä¿®æ”¹ï¼Œå› ä¸ºäºŒè€…éƒ½åŒ…å«äº†æŒ‡å‘åŒä¸€ä¸ªåº•å±‚æ•°ç»„çš„æŒ‡é’ˆ çœ‹è¿™æ ·ä¸€ä¸ªä¾‹å­ï¼Œå°† path ä¸­çš„å°å†™å­—æ¯è½¬æ¢ä¸ºå¤§å†™å­—æ¯ï¼š type path []byte func (p path) ToUpper() { for i, b := range p { if 'a' \u003c= b \u0026\u0026 b \u003c= 'z' { p[i] = b + 'A' - 'a' } } } func main() { pathName := path(\"/usr/bin/tso\") pathName.ToUpper() fmt.Printf(\"%s\\n\", pathName) } ä½¿ç”¨å€¼æ¥æ”¶è€…ï¼Œä¾ç„¶å¯ä»¥å®Œæˆä¿®æ”¹æ“ä½œï¼š /USR/BIN/TSO ä½¿ç”¨æŒ‡é’ˆæ¥æ”¶è€…ä¹Ÿä¼šå¾—åˆ°åŒæ ·çš„ç»“æœï¼š func (p *path) ToUpper() { for i, b := range *p { if 'a' \u003c= b \u0026\u0026 b \u003c= 'z' { (*p)[i] = b + 'A' - 'a' } } } ","date":"2021-05-05","objectID":"/slices_in_go/:4:0","tags":["Go","åˆ‡ç‰‡"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"Capacity ä¸‹é¢è¿™ä¸ªå‡½æ•°å°†å®ƒå‚æ•°ä¸­çš„åˆ‡ç‰‡æ‰©å±•äº†ä¸€ä¸ªæŒ‡å®šçš„å…ƒç´ ï¼š func Extend(slice []int, element int) []int { n := len(slice) slice = slice[0 : n+1] slice[n] = element return slice } ï¼ˆä¸ºä»€ä¹ˆéœ€è¦è¿”å›ä¿®æ”¹åçš„åˆ‡ç‰‡å‘¢ï¼Ÿï¼‰ç°åœ¨æˆ‘ä»¬è¿è¡Œå®ƒï¼š func main() { var iBuffer [10]int slice := iBuffer[0:0] for i := 0; i \u003c 20; i++ { slice = Extend(slice, i) fmt.Println(slice) } } ä¼šå¾—åˆ°è¿™æ ·çš„ç»“æœï¼š [0] [0 1] [0 1 2] [0 1 2 3] [0 1 2 3 4] [0 1 2 3 4 5] [0 1 2 3 4 5 6] [0 1 2 3 4 5 6 7] [0 1 2 3 4 5 6 7 8] [0 1 2 3 4 5 6 7 8 9] panic: runtime error: slice bounds out of range [:11] with capacity 10 goroutine 1 [running]: main.Extend(...) /tmp/sandbox070713439/prog.go:16 main.main() /tmp/sandbox070713439/prog.go:25 +0x105 ç°åœ¨æˆ‘ä»¬éœ€è¦è®¨è®ºä¸€ä¸‹ä¹‹å‰æåˆ°çš„åˆ‡ç‰‡å¤´ç»“æ„ä½“çš„ç¬¬ä¸‰ä¸ªå…ƒç´ äº†ï¼šå®ƒçš„å®¹é‡ï¼ˆcapacityï¼‰ã€‚é™¤äº†æ•°ç»„æŒ‡é’ˆå’Œé•¿åº¦ï¼Œåˆ‡ç‰‡å¤´ç»“æ„ä½“ä¸­è¿˜å­˜å‚¨äº†åˆ‡ç‰‡çš„å®¹é‡å€¼ï¼š type sliceHeader struct { Length int Capacity int ZerothElement *byte } å®¹é‡å­—æ®µè®°å½•äº†åº•å±‚æ•°ç»„å®é™…æ‹¥æœ‰å¤šå°‘ç©ºé—´ï¼Œå®ƒçš„å€¼å°±æ˜¯é•¿åº¦å­—æ®µå¯ä»¥è¾¾åˆ°çš„æœ€å¤§å€¼ã€‚å½“æˆ‘ä»¬è¯•å›¾æ‰©å±•åˆ‡ç‰‡è¶…è¿‡å®ƒçš„å®¹é‡å€¼æ—¶ï¼Œå°±ä¼šé€ æˆæ•°ç»„çš„è¶Šç•Œè®¿é—®ï¼Œä»è€Œå¯¼è‡´ç¨‹åºæŠ¥é”™ï¼ˆå°±åƒä¸Šé¢è¿™ä¸ªä¾‹å­ä¸€æ ·ï¼‰ã€‚ ä¸Šé¢è¿™ä¸ªä¾‹å­ä¸­æˆ‘ä»¬åˆ›å»ºäº†è¿™æ ·ä¸€ä¸ªåˆ‡ç‰‡ï¼š slice := iBuffer[0:0] å®ƒçš„åˆ‡ç‰‡å¤´ç»“æ„ä½“çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„ï¼š slice := sliceHeader{ Length: 0, Capacity: 10, ZerothElement: \u0026iBuffer[0], } å®ƒçš„å®¹é‡å€¼ç­‰äºå®ƒæŒ‡å‘çš„åº•å±‚æ•°ç»„ iBuffer çš„é•¿åº¦å‡å»åˆ‡ç‰‡æŒ‡å‘çš„ç¬¬ä¸€ä¸ªå…ƒç´ çš„ç´¢å¼•å€¼ï¼ˆåœ¨æœ¬ä¾‹ä¸­è¿™ä¸ªå€¼ä¸º0ï¼‰ã€‚å¯ä»¥ä½¿ç”¨å†…ç½®å‡½æ•° cap() æ¥è·å¾—åˆ‡ç‰‡çš„å®¹é‡ï¼š if cap(slice) == len(slice) { fmt.Println(\"slice is full!\") } ","date":"2021-05-05","objectID":"/slices_in_go/:5:0","tags":["Go","åˆ‡ç‰‡"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"Make æ ¹æ®å®šä¹‰ï¼Œåˆ‡ç‰‡çš„å®¹é‡å€¼é™åˆ¶äº†åˆ‡ç‰‡å¯æ‰©å±•çš„é•¿åº¦ï¼Œæˆ‘ä»¬æ— æ³•æ‰©å±•ä¸€ä¸ªåˆ‡ç‰‡è¶…è¿‡å®ƒçš„å®¹é‡ã€‚ä½†æ˜¯æˆ‘ä»¬å¯ä»¥ä½¿ç”¨è¿™æ ·çš„æ“ä½œæ¥å®ç°è¿™ä¸€ç›®çš„ï¼šåˆ†é…ä¸€ä¸ªæ–°æ•°ç»„ï¼Œå°†åŸæ•°ç»„æ•°æ®å¤åˆ¶è¿‡æ¥ï¼Œç„¶åä¿®æ”¹åˆ‡ç‰‡ä½¿å…¶æŒ‡å‘æ–°çš„æ•°ç»„ã€‚ ä¸‹é¢æˆ‘ä»¬æ¥å°è¯•ä¸€ä¸‹ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ new() å‡½æ•°æ¥åˆ†é…ä¸€ä¸ªæ›´å¤§çš„æ•°ç»„ç„¶ååˆ‡ç‰‡ï¼Œä½†æ˜¯ä½¿ç”¨ make() å‡½æ•°æ¥ä»£æ›¿ä¸Šè¿°æ“ä½œæ›´åŠ ç®€å•ã€‚ä»–ä¸€æ¬¡æ€§å®Œæˆäº†åˆ†é…äº†ä¸€ä¸ªæ–°çš„æ•°ç»„å¹¶ä¸”åœ¨æ•°ç»„ä¹‹ä¸Šåˆ›å»ºäº†ä¸€ä¸ªåˆ‡ç‰‡çš„æ“ä½œã€‚ make() å‡½æ•°æ¥å—ä¸‰ä¸ªå‚æ•°ï¼šåˆ‡ç‰‡ç±»å‹ï¼Œå®ƒçš„åˆå§‹é•¿åº¦ï¼Œå’Œå®ƒçš„å®¹é‡ï¼Œä¹Ÿå°±æ˜¯ make åˆ›å»ºçš„æ–°æ•°ç»„çš„é•¿åº¦ã€‚ä¸‹é¢çš„è¯­å¥åˆ›å»ºäº†é•¿åº¦ä¸º10ï¼Œå®¹é‡ä¸º15çš„åˆ‡ç‰‡ï¼š slice := make([]int, 10, 15) fmt.Printf(\"len: %d, cap: %d\\n\", len(slice), cap(slice)) è¿è¡Œç»“æœä¸ºï¼š len: 10, cap: 15 ä¸‹é¢è¿™æ®µä»£ç ä½¿åˆ‡ç‰‡çš„å®¹é‡ç¿»å€ï¼Œé•¿åº¦ä¸å˜ï¼š slice := make([]int, 10, 15) fmt.Printf(\"len: %d, cap: %d\\n\", len(slice), cap(slice)) newSlice := make([]int, len(slice), 2*cap(slice)) for i := range slice { newSlice[i] = slice[i] } slice = newSlice fmt.Printf(\"len: %d, cap: %d\\n\", len(slice), cap(slice)) è¿è¡Œç»“æœä¸ºï¼š len: 10, cap: 15 len: 10, cap: 30 å½“åˆ›å»ºåˆ‡ç‰‡æ—¶ï¼Œé•¿åº¦å’Œå®¹é‡å€¼é€šå¸¸æ˜¯ç›¸åŒçš„ã€‚ make å‡½æ•°å¯¹äºè¿™ç§æƒ…å†µæœ‰ä¸€ä¸ªç®€å†™ï¼š gophers := make([]Gopher, 10) åˆ‡ç‰‡ gophere çš„é•¿åº¦å’Œå®¹é‡å‡ä¸º10 ","date":"2021-05-05","objectID":"/slices_in_go/:6:0","tags":["Go","åˆ‡ç‰‡"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"Copy ä¸Šä¸€èŠ‚çš„ä¾‹å­ä¸­æˆ‘ä»¬ä½¿ç”¨äº†ä¸€ä¸ªå¾ªç¯æ¥å°†æ•°æ®å¤åˆ¶åˆ°æ–°çš„åˆ‡ç‰‡ä¸­ã€‚ Go æä¾›äº†ä¸€ä¸ªå‡½æ•° copy æ¥ä½¿å¤åˆ¶è¿‡ç¨‹æ›´åŠ ç®€å•ã€‚å®ƒçš„å‚æ•°æ˜¯ä¸¤ä¸ªåˆ‡ç‰‡ï¼Œå°†æ•°æ®ä»ç¬¬äºŒä¸ªåˆ‡ç‰‡ä¸­å¤åˆ¶åˆ°ç¬¬ä¸€ä¸ªåˆ‡ç‰‡ä¸­ï¼š newSlice := make([]int, len(slice), 2*cap(slice)) copy(newSlice, slice) copy å‡½æ•°åªå¤åˆ¶å®ƒèƒ½å¤Ÿå¤åˆ¶çš„å€¼ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒå¤åˆ¶çš„å…ƒç´ æ•°é‡æ˜¯ä¸¤ä¸ªåˆ‡ç‰‡çš„é•¿åº¦ä¸­çš„çš„æœ€å°å€¼ã€‚å®ƒè¿”å›å€¼ä¸€ä¸ª int å€¼ï¼Œä»£è¡¨å®ƒå¤åˆ¶çš„å…ƒç´ çš„æ•°é‡ã€‚ å½“ copy çš„ä¸¤ä¸ªå‚æ•°æ˜¯åŒä¸€ä¸ªå€¼æ—¶ï¼Œä»–ä¾ç„¶å¯ä»¥æ­£ç¡®çš„æ“ä½œï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ copy åœ¨ä¸€ä¸ªåˆ‡ç‰‡ä¸­ç§»åŠ¨å…ƒç´ ã€‚ä¸‹é¢è¿™ä¸ªä¾‹å­å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ copy åœ¨åˆ‡ç‰‡æŒ‡å®šä½ç½®æ’å…¥ä¸€ä¸ªå€¼ï¼š // Insert inserts the value into the slice at the specified index, // which must be in range. // The slice must have room for the new element. func Insert(slice []int, index, value int) []int { // Grow the slice by one element. slice = slice[0 : len(slice)+1] // Use copy to move the upper part of the slice out of the way and open a hole. copy(slice[index+1:], slice[index:]) // Store the new value. slice[index] = value // Return the result. return slice } å…³äºè¿™ä¸ªå‡½æ•°æœ‰å‡ ä»¶äº‹éœ€è¦æ³¨æ„ï¼šé¦–å…ˆï¼Œå®ƒå¿…é¡»è¿”å›ä¸€ä¸ªæ–°çš„åˆ‡ç‰‡ï¼Œå› ä¸ºåˆ‡ç‰‡çš„é•¿åº¦å€¼å·²ç»è¢«ä¿®æ”¹äº†ï¼›å…¶æ¬¡ï¼Œå®ƒä½¿ç”¨äº†ç®€å†™ slice[i:] ï¼Œç­‰åŒäº slice[i:len(slice)] ï¼Œå½“ç„¶æˆ‘ä»¬ä¹Ÿå¯ä»¥å¿½ç•¥è¿™ä¸ªè¡¨è¾¾å¼çš„ç¬¬ä¸€ä¸ªå€¼ï¼Œå®ƒé»˜è®¤ä¸º0ï¼Œä¹Ÿå°±æ˜¯ slice[:] ï¼Œå®ƒä»£è¡¨è¿™ä¸ªåˆ‡ç‰‡æœ¬èº«ã€‚å½“æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªæ‹¥æœ‰æ•°ç»„å…¨éƒ¨å…ƒç´ çš„åˆ‡ç‰‡æ—¶ï¼Œæˆ‘ä»¬å°±å¯ä»¥è¿™ä¹ˆå†™ï¼šarray[:] ã€‚ å¥½äº†ï¼Œç°åœ¨æˆ‘ä»¬æ¥è¿è¡Œä¸€ä¸‹ä¸Šé¢è¿™ä¸ªä¾‹å­ï¼š slice := make([]int, 10, 20) // Note capacity \u003e length: room to add element. for i := range slice { slice[i] = i } fmt.Println(slice) slice = Insert(slice, 5, 99) fmt.Println(slice) è¿è¡Œç»“æœä¸ºï¼š [0 1 2 3 4 5 6 7 8 9] [0 1 2 3 4 99 5 6 7 8 9] ","date":"2021-05-05","objectID":"/slices_in_go/:7:0","tags":["Go","åˆ‡ç‰‡"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"Append: An example åœ¨Capacityé‚£ä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬å†™äº†ä¸ª Extend å‡½æ•°æ¥ä¸ºåˆ‡ç‰‡æ‰©å±•ä¸€ä¸ªå…ƒç´ ã€‚ç¨‹åºåœ¨è¿è¡Œæ—¶ä¼šæŠ¥é”™ï¼Œå› ä¸ºæˆ‘ä»¬è®¾å®šçš„åˆ‡ç‰‡çš„å®¹é‡å¤ªå°ï¼Œå¯¼è‡´åº•å±‚æ•°ç»„è¶Šç•Œè®¿é—®é€ æˆç¨‹åºå´©æºƒã€‚ç°åœ¨æˆ‘ä»¬å·²ç»è§£å†³äº†è¿™ä¸€é—®é¢˜ï¼Œå¯ä»¥ç¼–å†™ä¸€ä¸ªå¥å£®çš„ Extend çš„å®ç°ï¼š func Extend(slice []int, element int) []int { n := len(slice) if n == cap(slice) { // Slice is full; must grow. // We double its size and add 1, so if the size is zero we still grow. newSlice := make([]int, len(slice), 2*len(slice)+1) copy(newSlice, slice) slice = newSlice } slice = slice[0 : n+1] slice[n] = element return slice } è¿™ä¸ªä¾‹å­ä¸­æˆ‘ä»¬è¿”å›äº†ä¸€ä¸ªåˆ‡ç‰‡ï¼Œå› ä¸ºä¸åŸåˆ‡ç‰‡ç›¸æ¯”ï¼Œè¿”å›çš„åˆ‡ç‰‡å®é™…ä¸ŠæŒ‡å‘äº†æˆ‘ä»¬é‡æ–°åˆ†é…çš„åº•å±‚æ•°ç»„ï¼Œä¸åŸåˆ‡ç‰‡å®Œå…¨ä¸åŒã€‚ä¸‹é¢è¿™æ®µä»£ç å±•ç¤ºäº†åˆ‡ç‰‡åœ¨å¡«å……è¿‡ç¨‹ä¸­å‘ç”Ÿäº†ä»€ä¹ˆï¼š slice := make([]int, 0, 5) for i := 0; i \u003c 10; i++ { slice = Extend(slice, i) fmt.Printf(\"len=%d cap=%d slice=%v\\n\", len(slice), cap(slice), slice) fmt.Println(\"address of 0th element:\", \u0026slice[0]) } å…¶ç»“æœä¸ºï¼š len=1 cap=5 slice=[0] address of 0th element: 0xc00007a030 len=2 cap=5 slice=[0 1] address of 0th element: 0xc00007a030 len=3 cap=5 slice=[0 1 2] address of 0th element: 0xc00007a030 len=4 cap=5 slice=[0 1 2 3] address of 0th element: 0xc00007a030 len=5 cap=5 slice=[0 1 2 3 4] address of 0th element: 0xc00007a030 len=6 cap=11 slice=[0 1 2 3 4 5] address of 0th element: 0xc000062060 len=7 cap=11 slice=[0 1 2 3 4 5 6] address of 0th element: 0xc000062060 len=8 cap=11 slice=[0 1 2 3 4 5 6 7] address of 0th element: 0xc000062060 len=9 cap=11 slice=[0 1 2 3 4 5 6 7 8] address of 0th element: 0xc000062060 len=10 cap=11 slice=[0 1 2 3 4 5 6 7 8 9] address of 0th element: 0xc000062060 åŸå§‹æ•°ç»„å®¹é‡åªæœ‰5ï¼Œå½“åŸå§‹æ•°ç»„è¢«å¡«æ»¡æ—¶ï¼Œé‡æ–°åˆ†é…äº†ä¸€ä¸ªå®¹é‡ä¸º11çš„æ•°ç»„ï¼Œæ­¤æ—¶ç¬¬0ä¸ªå…ƒç´ çš„åœ°å€ä¹Ÿæ”¹å˜äº†ã€‚ æ ¹æ®è¿™ä¸ªä¾‹å­çš„æ€è·¯ï¼Œæˆ‘ä»¬å¯ä»¥å†™ä¸€ä¸ªæ›´å¥½çš„å‡½æ•° Append æ¥ä¸ºåˆ‡ç‰‡ä¸€æ¬¡æ€§æ‰©å……å¤šä¸ªå…ƒç´ ã€‚è¿™æˆ‘ä»¬ä¼šç”¨åˆ° Go è¯­è¨€çš„å¯å˜å‚æ•°å‡½æ•°ï¼Œåœ¨å£°æ˜å¯å˜å‚æ•°å‡½æ•°æ—¶ï¼Œéœ€è¦åœ¨å‚æ•°åˆ—è¡¨çš„æœ€åä¸€ä¸ªå‚æ•°ç±»å‹ä¹‹å‰åŠ ä¸Šçœç•¥ç¬¦å·â€œâ€¦â€ï¼Œè¿™è¡¨ç¤ºè¯¥å‡½æ•°ä¼šæ¥æ”¶ä»»æ„æ•°é‡çš„è¯¥ç±»å‹å‚æ•°ã€‚ ä½œä¸ºæœ€åˆçš„å®ç°ï¼Œæˆ‘ä»¬å¯ä»¥å°†å¯¹ Extend è¿›è¡Œå¤šæ¬¡è°ƒç”¨ã€‚ Append çš„å‡½æ•°ç­¾åå¦‚ä¸‹ï¼š func Append(slice []int, items ...int) []int Append å‡½æ•°æ¥æ”¶ä¸€ä¸ªåˆ‡ç‰‡ä»¥åŠä»»æ„å¤šä¸ª int ç±»å‹çš„å…ƒç´ ï¼Œè¿™äº›å…ƒç´ å®é™…ä¸Šè¢«å½“æˆä¸€ä¸ªåˆ‡ç‰‡æ¥è¿›è¡Œå¤„ç†ï¼š // Append appends the items to the slice. // First version: just loop calling Extend. func Append(slice []int, items ...int) []int { for _, item := range items { slice = Extend(slice, item) } return slice } æ‰§è¡Œä»¥ä¸‹è¯­å¥ï¼š slice := []int{0, 1, 2, 3, 4} fmt.Println(slice) slice = Append(slice, 5, 6, 7, 8) fmt.Println(slice) å…¶ç»“æœä¸ºï¼š [0 1 2 3 4] [0 1 2 3 4 5 6 7 8] æ³¨æ„åˆ°è¿™é‡Œæˆ‘ä»¬åŒæ—¶å£°æ˜å¹¶åˆå§‹åŒ–äº†ä¸€ä¸ªåˆ‡ç‰‡ï¼š slice := []int{0, 1, 2, 3, 4} æˆ‘ä»¬ä¸ä»…å¯ä»¥ä¼ å…¥ä»»æ„å¤šä¸ªå‚æ•°ï¼Œè¿˜å¯ä»¥ä»¥åˆ‡ç‰‡çš„å½¢å¼ä¼ å…¥å‚æ•°ï¼Œä¸è¿‡å¿…é¡»åœ¨åˆ‡ç‰‡åé¢åŠ ä¸Š ... ï¼š slice1 := []int{0, 1, 2, 3, 4} slice2 := []int{55, 66, 77} fmt.Println(slice1) slice1 = Append(slice1, slice2...) // The '...' is essential! fmt.Println(slice1 å…¶ç»“æœä¸ºï¼š [0 1 2 3 4] [0 1 2 3 4 55 66 77] æˆ‘ä»¬å¯ä»¥æ”¹å†™ä¸€ä¸‹é‡åˆ†é…æ•°ç»„çš„æ¡ä»¶ï¼Œä½¿å…¶æ›´æœ‰æ•ˆç‡ï¼š // Append appends the elements to the slice. // Efficient version. func Append(slice []int, elements ...int) []int { n := len(slice) total := len(slice) + len(elements) if total \u003e cap(slice) { // Reallocate. Grow to 1.5 times the new size, so we can still grow. newSize := total*3/2 + 1 newSlice := make([]int, total, newSize) copy(newSlice, slice) slice = newSlice } slice = slice[:total] copy(slice[n:], elements) return slice } è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨äº†ä¸¤æ¬¡ copy ï¼Œä¸€æ¬¡ç”¨äºå°†æ•°æ®å¤åˆ¶è¿›æ–°çš„æ•°ç»„ï¼Œä¸€æ¬¡ç”¨äºå°†æ–°çš„æ•°æ®å¤åˆ¶åˆ°æ•°ç»„çš„æœ«å°¾ã€‚è¿™å’Œæœ€åˆçš„å‡½æ•°å…·æœ‰åŒæ ·çš„æ•ˆåŠ›ã€‚ ","date":"2021-05-05","objectID":"/slices_in_go/:8:0","tags":["Go","åˆ‡ç‰‡"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"Append: The build-in function åˆ°æ­¤æˆ‘ä»¬å·²ç»æ˜ç™½äº†å†…ç½®å‡½æ•° append çš„è®¾è®¡åŠ¨æœºã€‚å®ƒå’Œæˆ‘ä»¬çš„ Append ç›¸ä¼¼ï¼Œæ•ˆç‡ä¸Šä¹Ÿå·®ä¸å¤šï¼Œä½†æ˜¯å®ƒé€‚ç”¨äºä»»ä½•åˆ‡ç‰‡ç±»å‹ã€‚ Go è¯­è¨€çš„ä¸€ä¸ªç¼ºç‚¹æ˜¯ä»»ä½•æ³›å‹æ“ä½œå¿…é¡»ç”±è¿è¡Œæ—¶æä¾›ã€‚ä»¥åä¹Ÿè®¸ä¼šæ”¹å˜ï¼Œä½†æ˜¯ç°åœ¨ï¼Œä¸ºäº†ä½¿åˆ‡ç‰‡æ“ä½œæ›´åŠ ç®€å•ï¼Œ Go æä¾›äº†å†…ç½®çš„æ³›å‹ append å‡½æ•°ã€‚å®ƒé€‚ç”¨äºä»»ä½•ç±»å‹ã€‚ ç”±äºåˆ‡ç‰‡å¤´ç»“æ„ä½“ç»å¸¸ä¼šè¢« append ä¿®æ”¹ï¼Œä½ éœ€è¦ä¿å­˜è¿”å›çš„åˆ‡ç‰‡å€¼ã€‚äº‹å®ä¸Šï¼Œç¼–è¯‘å™¨ä¸å…è®¸ä½ åœ¨ä¸ä¿å­˜ç»“æœçš„æƒ…å†µä¸‹è°ƒç”¨ append ã€‚ ä¸‹é¢æ˜¯ä¸€äº›ä½¿ç”¨ append çš„è¯­å¥ï¼š // Create a couple of starter slices. slice := []int{1, 2, 3} slice2 := []int{55, 66, 77} fmt.Println(\"Start slice: \", slice) fmt.Println(\"Start slice2:\", slice2) // Add an item to a slice. slice = append(slice, 4) fmt.Println(\"Add one item:\", slice) // Add one slice to another. slice = append(slice, slice2...) fmt.Println(\"Add one slice:\", slice) // Make a copy of a slice (of int). slice3 := append([]int(nil), slice...) fmt.Println(\"Copy a slice:\", slice3) // Copy a slice to the end of itself. fmt.Println(\"Before append to self:\", slice) slice = append(slice, slice...) fmt.Println(\"After append to self:\", slice) è¿è¡Œç»“æœä¸ºï¼š Start slice: [1 2 3] Start slice2: [55 66 77] Add one item: [1 2 3 4] Add one slice: [1 2 3 4 55 66 77] Copy a slice: [1 2 3 4 55 66 77] Before append to self: [1 2 3 4 55 66 77] After append to self: [1 2 3 4 55 66 77 1 2 3 4 55 66 77] æœ‰å¿…è¦èŠ±ç‚¹æ—¶é—´æ€è€ƒä¸€ä¸‹æœ€åä¸€è¡Œçš„ç¤ºä¾‹æ¥ç†è§£åˆ‡ç‰‡çš„è®¾è®¡å¦‚ä½•ä½¿è¿™ä¸ªæ“ä½œæ­£ç¡®çš„æ‰§è¡Œ åœ¨â€œSlice Tricksâ€æœ‰æ›´å¤šçš„å…³äº append ã€copy ä»¥åŠåˆ‡ç‰‡çš„å…¶ä»–ç”¨æ³•çš„ä¾‹å­ã€‚ ","date":"2021-05-05","objectID":"/slices_in_go/:9:0","tags":["Go","åˆ‡ç‰‡"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"Nil ç°åœ¨æˆ‘ä»¬å¯ä»¥æ¥çœ‹ä¸€ä¸‹ nil åˆ‡ç‰‡ä»£è¡¨ç€ä»€ä¹ˆã€‚è‡ªç„¶çš„ï¼Œå®ƒä»£è¡¨ç€åˆ‡ç‰‡å¤´ç»“æ„ä½“çš„é›¶å€¼ï¼š sliceHeader{ Length: 0, Capacity: 0, ZerothElement: nil, } æˆ–è€…æ˜¯ï¼š sliceHeader{} æ³¨æ„æ­¤æ—¶æŒ‡é’ˆçš„å€¼ä¹Ÿæ˜¯ nil ã€‚è€Œç”± array[0:0] åˆ›å»ºçš„åˆ‡ç‰‡é•¿åº¦ä¸ºé›¶ï¼Œä½†æ˜¯å®ƒçš„æŒ‡é’ˆå€¼ä¸æ˜¯ nil ï¼Œå› ä¸ºå®ƒç¡®å®æŒ‡å‘äº†ä¸€ä¸ªå­˜åœ¨çš„æ•°ç»„ï¼Œæ‰€ä»¥å®ƒä¸æ˜¯ä¸€ä¸ª nil åˆ‡ç‰‡ã€‚ è¦çŸ¥é“ï¼Œä¸€ä¸ªç©ºçš„åˆ‡ç‰‡ï¼ˆå‡è®¾å®ƒçš„å®¹é‡ä¸ä¸º0ï¼‰æ˜¯å¯ä»¥æ‰©å……çš„ï¼Œä½†æ˜¯ä¸€ä¸ª nil åˆ‡ç‰‡ç”±äºæ²¡æœ‰å¯ä»¥å¡«å……å…ƒç´ çš„åº•å±‚æ•°ç»„ï¼Œæ‰€ä»¥æ˜¯æ— æ³•æ‰©å……çš„ã€‚ nil å¯ä»¥é€šè¿‡é‡åˆ†é…æ•°ç»„çš„æ–¹å¼æ¥è¿½åŠ å…ƒç´ ï¼Œæ­£å¦‚ä¸Šä¸€èŠ‚æ‰€è®²çš„ã€‚ ","date":"2021-05-05","objectID":"/slices_in_go/:10:0","tags":["Go","åˆ‡ç‰‡"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"Strings è¿™ä¸€èŠ‚ç”¨äºç®€çŸ­çš„ä»‹ç»ä¸€ä¸‹ Go è¯­è¨€ä¸­åœ¨åˆ‡ç‰‡èƒŒæ™¯ä¸‹çš„å­—ç¬¦ä¸²ã€‚ å­—ç¬¦ä¸²å¾ˆç®€å•ï¼šå®ƒæ˜¯åªè¯»çš„å­—èŠ‚åˆ‡ç‰‡ï¼Œå¤–åŠ ä¸€ç‚¹æ¥è‡ªè¯­è¨€çš„é¢å¤–çš„è¯­æ³•æ”¯æŒã€‚ å› ä¸ºå­—ç¬¦ä¸²æ˜¯åªè¯»çš„ï¼Œæ‰€ä»¥å®ƒä»¬å¹¶ä¸éœ€è¦å®¹é‡ï¼ˆä½ ä¸èƒ½æ‰©å……ä»–ä»¬ï¼‰ï¼Œä½†æ˜¯å¤§å¤šæ•°æƒ…å†µä¸‹ä½ å¯ä»¥æŠŠå®ƒä»¬è§†ä¸ºåªè¯»çš„å­—èŠ‚åˆ‡ç‰‡ã€‚ æˆ‘ä»¬å¯ä»¥é€šè¿‡ç´¢å¼•è®¿é—®å•ä¸ªå­—èŠ‚ï¼š slash := \"/usr/ken\"[0] // yields the byte value '/'. å¯ä»¥å¯¹å­—ç¬¦ä¸²è¿›è¡Œåˆ‡ç‰‡æ¥è·å–å­ä¸²ï¼š usr := \"/usr/ken\"[0:4] // yields the string \"/usr\" å½“æˆ‘ä»¬å¯¹å­—ç¬¦ä¸²è¿›è¡Œåˆ‡ç‰‡æ—¶ï¼Œå¹•åå‘ç”Ÿäº†ä»€ä¹ˆä½ åº”è¯¥å·²ç»äº†è§£äº†ã€‚ æˆ‘ä»¬ä¹Ÿå¯ä»¥ç”¨ä¸€ä¸ªæ™®é€šçš„å­—èŠ‚åˆ‡ç‰‡æ¥åˆ›å»ºå­—ç¬¦ä¸²ï¼š str := string(slice) æˆ–è€…åè¿‡æ¥æ“ä½œï¼š slice := []byte(usr) å­—ç¬¦ä¸²çš„åº•å±‚æ•°ç»„å¯¹äºæˆ‘ä»¬æ¥è¯´æ˜¯ä¸å¯è§çš„ï¼Œé™¤äº†é€šè¿‡å­—ç¬¦ä¸²æœ¬èº«ï¼Œæˆ‘ä»¬æ— æ³•è®¿é—®åˆ°å®ƒçš„å†…å®¹ã€‚ä¹Ÿå°±æ˜¯è¯´åœ¨è¿›è¡Œä¸Šé¢çš„è½¬æ¢æ—¶ï¼Œå¿…é¡»å¤åˆ¶æ•°ç»„ï¼Œä¸è¿‡ Go è¯­è¨€å¸®æˆ‘ä»¬å¤„ç†äº†ã€‚å®Œæˆè½¬æ¢ä¹‹åï¼Œå¯¹äºå­—èŠ‚åˆ‡ç‰‡åº•å±‚æ•°ç»„çš„ä¿®æ”¹å¹¶ä¸ä¼šå½±å“å¯¹åº”çš„å­—ç¬¦ä¸²ï¼Œå› ä¸ºä»–ä»¬æŒ‡å‘çš„æ˜¯ä¸åŒçš„åº•å±‚æ•°ç»„ã€‚ è¿™ç§ç±»åˆ‡ç‰‡çš„å­—ç¬¦ä¸²è®¾è®¡ä½¿å¾—åˆ›å»ºå­å­—ç¬¦ä¸²éå¸¸å®¹æ˜“ï¼Œæˆ‘ä»¬åªéœ€è¦åˆ›å»ºä¸€ä¸ªå­—ç¬¦ä¸²å¤´å³å¯ï¼Œç”±äºå­—ç¬¦ä¸²æ˜¯åªè¯»çš„ï¼Œå› æ­¤å­ä¸²å¯ä»¥å’ŒåŸå­—ç¬¦ä¸²å®‰å…¨çš„å…±äº«ç›¸åŒçš„åº•å±‚æ•°ç»„ã€‚ è¿™ç¯‡åšå®¢æ›´åŠ æ·±å…¥çš„ä»‹ç»äº†æœ‰å…³å­—ç¬¦ä¸²çš„å†…å®¹ã€‚ ","date":"2021-05-05","objectID":"/slices_in_go/:11:0","tags":["Go","åˆ‡ç‰‡"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"Conclusion äº†è§£åˆ‡ç‰‡çš„å·¥ä½œåŸç†æœ‰åŠ©äºäº†è§£åˆ‡ç‰‡çš„å®ç°æ–¹å¼ã€‚ä¸€ä¸ªå…³é”®çš„æ•°æ®ç»“æ„ï¼Œå³åˆ‡ç‰‡å¤´ç»“æ„ä½“ï¼Œå®ƒä¸åˆ‡ç‰‡å˜é‡ç›¸å…³è”ï¼Œå¹¶ä¸”å®ƒæè¿°äº†åº•å±‚æ•°ç»„çš„ä¸€éƒ¨åˆ†ã€‚å½“æˆ‘ä»¬ä¼ é€’åˆ‡ç‰‡å€¼æ—¶ï¼Œå°†ä¼ é€’åˆ‡ç‰‡å¤´ç»“æ„ä½“çš„å‰¯æœ¬ï¼Œä½†å®ƒå§‹ç»ˆæŒ‡å‘åŒä¸€ä¸ªåº•å±‚æ•°ç»„ã€‚ ä¸€æ—¦ä½ äº†è§£äº†åˆ‡ç‰‡çš„å·¥ä½œåŸç†ï¼Œä½ ä¼šå‘ç°åˆ‡ç‰‡ä¸ä»…ä¾¿äºä½¿ç”¨ï¼Œè€Œä¸”éå¸¸å¼ºå¤§ï¼Œç‰¹åˆ«æ˜¯åœ¨å¤šä¸ªå†…ç½®å‡½æ•°çš„åŠ æŒä¸‹ã€‚ ","date":"2021-05-05","objectID":"/slices_in_go/:12:0","tags":["Go","åˆ‡ç‰‡"],"title":"slice in Go","uri":"/slices_in_go/"},{"categories":["Go"],"content":"More reading é™¤äº†å‰é¢æåˆ°çš„â€œSlice Tricksâ€ï¼ŒGo Slicesè¿™ç¯‡åšå®¢ç”¨å›¾è¡¨æè¿°äº†å†…å­˜å¸ƒå±€çš„ç»†èŠ‚ã€‚Russ Coxå†™çš„Go Data Structuresè¿™ç¯‡æ–‡ç« åŒ…æ‹¬äº†å¯¹åˆ‡ç‰‡çš„è®¨è®ºä»¥åŠå…¶ä»– Go è¯­è¨€å†…ç½®çš„æ•°æ®ç»“æ„ã€‚ è¿˜æœ‰å¾ˆå¤šå¯ç”¨çš„èµ„æ–™ï¼Œä½†æ˜¯æœ€å¥½çš„å­¦ä¹ æ–¹æ³•è¿˜æ˜¯åœ¨codingä¸­å»ä½¿ç”¨å®ƒä»¬ã€‚ ","date":"2021-05-05","objectID":"/slices_in_go/:13:0","tags":["Go","åˆ‡ç‰‡"],"title":"slice in Go","uri":"/slices_in_go/"}]